<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>급변 세계 시뮬레이터 — 구경 전용</title>
<style>
  :root {
    --bg: #0b0f14; --panel: #111823; --ink: #e6edf3; --muted: #8aa4b1;
    --accent: #4cc9f0; --accent2: #b8f2ff;
    --sea: #1a5b7a; --land: #3c8d5a; --mount: #7a6b59; --hit: #ffe066;
  }
  html, body { height: 100%; }
  body { margin: 0; background: var(--bg); color: var(--ink); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Noto Sans, Apple SD Gothic Neo, sans-serif; display: grid; grid-template-rows: auto 1fr auto; gap: 8px; }
  header { padding: 12px 16px; background: linear-gradient(180deg, #0d1520, #0c1320); box-shadow: 0 1px 0 #0008 inset; }
  header h1 { margin: 0; font-size: 18px; letter-spacing: .5px; color: var(--accent2); }
  header .meta { color: var(--muted); font-size: 12px; margin-top: 4px; }
  main { display: grid; grid-template-columns: 1fr; gap: 10px; padding: 0 10px 10px; }
  #stageWrap { position: relative; width: fit-content; margin: 0 auto; box-shadow: 0 10px 30px #0009; border-radius: 10px; overflow: hidden; background:#0a0f14; }
  canvas { display: block; image-rendering: pixelated; }
  #terrain, #countries { position: absolute; left:0; top:0; }
  #ui { background: var(--panel); border-radius: 12px; padding: 12px; box-shadow: 0 2px 0 #000a inset; }
  #ui h3 { margin: 0 0 8px; font-size: 14px; color: var(--accent); }
  .row { display:flex; gap:8px; align-items:center; flex-wrap: wrap; margin-bottom:8px; }
  button, select { background: #0f1926; color: var(--ink); border:1px solid #203043; border-radius: 10px; padding: 8px 10px; cursor: pointer; font-weight: 600; }
  button:hover { border-color:#375672; }
  button:disabled { opacity:.5; cursor:not-allowed; }
  #ticker { background:#0c141d; border:1px solid #182333; border-radius: 10px; padding:8px; font-size:12px; height: 280px; overflow:auto; }
  #ticker b { color:#ffd670; }
  #stats { display:grid; grid-template-columns: 1fr 1fr; gap:8px; margin-top:8px; }
  .statBox { background:#0c141d; border:1px solid #182333; border-radius:10px; padding:8px; font-size:12px; }
  .spark { width:100%; height:50px; background:#07101a; border-radius:6px; display:block; }
  .tag { background:#132031; color:#9dc6ff; padding:2px 6px; border-radius: 999px; font-size: 11px; }
  footer { display:flex; justify-content: space-between; align-items:center; padding: 6px 12px; color: var(--muted); font-size: 12px; }
  .legend { display:flex; gap:8px; align-items:center; }
  .chip { display:inline-flex; align-items:center; gap:6px; padding:2px 8px; border-radius:999px; background:#0f1722; border:1px solid #223046; }
  .dot { width:12px; height:12px; border-radius:3px; }
  .dSea { background:var(--sea); }
  .dLand { background:var(--land); }
  .dMount { background:var(--mount); }
  .pill { padding: 2px 8px; background:#0f1722; border:1px solid #223046; border-radius:999px; }
  /* 랭킹 패널 (캔버스 우상단 오버레이) */
  #rank{ position:absolute; right:8px; top:8px; background:#0c141dd9; border:1px solid #182333; border-radius:8px; padding:8px 10px; font-size:12px; max-width:220px; backdrop-filter: blur(2px); }
  #rank .item{ display:flex; justify-content:space-between; gap:8px; margin:2px 0; }
  #rank .name{ font-weight:700; }
</style>
</head>
<body>
  <header>
    <h1>급변 세계 시뮬레이터 — 관찰 모드</h1>
    <div class="meta">시드: <span id="seedOut">-</span> · 턴: <span id="turnOut">0</span> · 속도: <span id="speedOut">1×</span></div>
  </header>
  <main>
    <div id="stageWrap">
      <canvas id="terrain" width="720" height="384"></canvas>
      <canvas id="countries" width="720" height="384"></canvas>
      <div id="rank"></div>
    </div>
    <aside id="ui">
      <h3>컨트롤</h3>
      <div class="row">
        <label for="speed">속도</label>
        <select id="speed">
          <option value="0.5">0.5×</option>
          <option value="1" selected>1×</option>
          <option value="2">2×</option>
          <option value="4">4×</option>
          <option value="8">8×</option>
          <option value="16">16×</option>
          <option value="32">32×</option>
        </select>
        <button id="pauseBtn">일시정지</button>
        <button id="resumeBtn" disabled>재개</button>
        <button id="restartBtn">새로시작</button>
      </div>
      <div class="row"><span class="tag">이벤트 티커</span></div>
      <div id="ticker"></div>
      <div id="stats">
        <div class="statBox">
          <div>국가 수 N</div>
          <canvas id="sparkN" class="spark" width="266" height="50"></canvas>
        </div>
        <div class="statBox">
          <div>최대국 점유율 G</div>
          <canvas id="sparkG" class="spark" width="266" height="50"></canvas>
        </div>
      </div>
    </aside>
  </main>
  <footer>
    <div class="legend">
      <span class="chip"><span class="dot dSea"></span>바다</span>
      <span class="chip"><span class="dot dLand"></span>평지</span>
      <span class="chip"><span class="dot dMount"></span>산맥</span>
      <span class="pill">관찰 전용 · 상호작용 없음</span>
    </div>
    <div>© world-sim — seed-based random; single-file build</div>
  </footer>

<script>
// ====== 기본 상수 ======
const W = 90, H = 48;               // 격자 크기 (기존 대비 1.5×)
const CELL = 8;                     // 셀 픽셀 크기 재조정(90×8=720, 48×8=384로 캔버스 동일 유지)
const LAND_TARGET = 0.50;           // 토지 비율 목표
const MOUNT_TARGET = 0.16;          // 산맥 비율 목표(육지 대비)

// 이벤트 베이스 파라미터(이벤트 로직은 유지)
const W0 = 0.015;  // 전쟁 기본 확률 계수
const R0 = 0.003;  // 반란 기본 확률 계수
const U0 = 0.06;   // 연합합병 기본 확률 계수
const MAX_P_WAR = 0.35;
const MAX_P_REB = 0.25;

// ====== 색 팔레트 ======
function makePalette(n, rng){
  const arr = [];
  for(let i=0;i<n;i++){
    const h = (i*137.508 + rng()*30) % 360; // 골든앵글 분산
    const s = 65 + rng()*25; const l = 50 + rng()*10;
    arr.push(hslToHex(h, s, l));
  }
  return arr;
}
function hslToHex(h, s, l) {
  s/=100; l/=100; const k=n=>(n+h/30)%12,
  a=s*Math.min(l,1-l),
  f=n=>l-a*Math.max(-1,Math.min(k(n)-3, Math.min(9-k(n),1)));
  const toHex = x=>{ const v=Math.round(255*x).toString(16).padStart(2,'0'); return v; };
  return `#${toHex(f(0))}${toHex(f(8))}${toHex(f(4))}`;
}

// ====== RNG ======
function mulberry32(seed){
  return function(){
    let t = seed += 0x6D2B79F5;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  }
}
function randInt(rng, a,b){ return Math.floor(rng()*(b-a+1))+a; }
function choice(rng, arr){ return arr[Math.floor(rng()*arr.length)]; }
function sampleLogNormal(rng, sigma=0.35){
  const u1 = Math.max(rng(),1e-12), u2=rng();
  const z = Math.sqrt(-2*Math.log(u1))*Math.cos(2*Math.PI*u2);
  return Math.exp(sigma*z);
}
function samplePareto(rng, k=1.8, xm=1){
  const u = 1 - rng(); return xm / Math.pow(u, 1/k);
}

// ====== 캔버스 ======
const terrainCV = document.getElementById('terrain');
const terr = terrainCV.getContext('2d');
const countryCV = document.getElementById('countries');
const ctx = countryCV.getContext('2d');
const sparkN = document.getElementById('sparkN').getContext('2d');
const sparkG = document.getElementById('sparkG').getContext('2d');
// 부모 래퍼가 absolute 자식의 크기를 못 잡아서 0x0이 되는 문제 수정
const stageWrap = document.getElementById('stageWrap');
stageWrap.style.width = terrainCV.width + 'px';
stageWrap.style.height = terrainCV.height + 'px';

// ====== 상태 ======
let rng, seed;
let gridTerrain; // 0=바다,1=평지,2=산
let gridCountry; // 국가ID or -1
let isIsthmus;   // 지협 태그
let C;           // 국가 배열
let colors;      // 국가 색상
let borderEdges; // 국경쌍 목록
let turn = 0; let paused = false; let speed = 1; let T = 1.0;
let eventScoreRing = []; // 최근 10턴 점수
let Nspark = [], Gspark = [];
let highlights = [];

// ====== 유틸 ======
function idx(x,y){ return y*W + x; }
function inside(x,y){ return x>=0&&x<W&&y>=0&&y<H; }
function forEachCell(cb){ for(let y=0;y<H;y++) for(let x=0;x<W;x++) cb(x,y); }
function neighbors4(x,y){ return [[x+1,y],[x-1,y],[x,y+1],[x,y-1]].filter(([a,b])=>inside(a,b)); }
function getCSS(v){ return getComputedStyle(document.documentElement).getPropertyValue(v).trim(); }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function median(arr){ if(arr.length===0) return 0; const s=[...arr].sort((a,b)=>a-b); const m=(s.length-1)/2; return (s[Math.floor(m)]+s[Math.ceil(m)])/2; }
function maxSize(){ return C.reduce((p,c)=>Math.max(p,c.cells.size),0); }
function frontierRatio(c){ let border=0; c.cells.forEach(g=>{ const x=g%W,y=(g/W)|0; if(neighbors4(x,y).some(([a,b])=>{ const id=gridCountry[idx(a,b)]; return id>=0 && id!==c.id; })) border++; }); return border/Math.max(1,c.cells.size); }

// ====== 값 노이즈 ======
function hash2(i,j, s){ let h = i*374761393 + j*668265263 ^ s; h = (h ^ (h>>13)) * 1274126177; return ((h ^ (h>>16)) >>> 0) / 4294967296; }
function valueNoise2D(x,y, s){ const xi=Math.floor(x), yi=Math.floor(y); const xf=x-xi, yf=y-yi; const v00=hash2(xi,yi,s), v10=hash2(xi+1,yi,s), v01=hash2(xi,yi+1,s), v11=hash2(xi+1,yi+1,s); const u=xf*xf*(3-2*xf), v=yf*yf*(3-2*yf); const x1=v00*(1-u)+v10*u, x2=v01*(1-u)+v11*u; return x1*(1-v)+x2*v; }
function octaveNoise(x,y,s, oct=4, lac=2, gain=0.5){ let amp=1, freq=1, sum=0, norm=0; for(let i=0;i<oct;i++){ sum+=amp*valueNoise2D(x*freq,y*freq,s+i*7919); norm+=amp; amp*=gain; freq*=lac; } return sum/norm; }

// ====== 지도 생성 ======
// === 다중 대륙 필드 (큰 덩어리 여러 개) ===
let continentSeeds = [];
function initContinents(){
  continentSeeds.length = 0;
  const n = randInt(rng,4,7); // 대륙 개수 소폭 증가 4~7
  for(let i=0;i<n;i++){
    const cx = randInt(rng, Math.floor(W*0.15), Math.floor(W*0.85));
    const cy = randInt(rng, Math.floor(H*0.15), Math.floor(H*0.85));
    const rx = randInt(rng, Math.floor(W*0.18), Math.floor(W*0.28));
    const ry = randInt(rng, Math.floor(H*0.18), Math.floor(H*0.28));
    const ang = rng()*Math.PI*2;
    continentSeeds.push({cx,cy,rx,ry,ang});
  }
}
function continentField(x,y){
  // 각 시드의 타원형 가우시안 범프의 최대값 → 분리된 큰 덩어리
  let v = 0;
  for(const s of continentSeeds){
    const cos = Math.cos(s.ang), sin = Math.sin(s.ang);
    const dx = x - s.cx, dy = y - s.cy;
    const rx = (dx*cos + dy*sin)/s.rx;
    const ry = (-dx*sin + dy*cos)/s.ry;
    const d2 = rx*rx + ry*ry;
    const bump = Math.exp(-d2); // 1 at center → 0 toward edge
    if(bump > v) v = bump;
  }
  return v; // 0..1 근사
}

function generateMap(){
  gridTerrain = new Uint8Array(W*H);
  gridCountry = new Int16Array(W*H).fill(-1);
  isIsthmus = new Uint8Array(W*H).fill(0);

  const scale = 0.12; // 해상도↑ → 패턴 세분화
const heights = new Float32Array(W*H);
initContinents();
forEachCell((x,y)=>{
  const nx = x*scale, ny = y*scale;
  const cont = continentField(x,y);                     // 대륙 큰 덩어리
  const detail = octaveNoise(nx,ny, 123456 + (seed&0xffff), 4, 1.9, 0.55); // 지역 디테일
  const macro  = octaveNoise(nx*0.35, ny*0.35, 98765 + (seed>>>16), 2, 1.8, 0.6); // 장주기 요철
  const h = 0.6*cont + 0.35*detail + 0.05*macro;       // 블렌딩
  heights[idx(x,y)] = h;
});

  // 임계값으로 바다/육지/산 분리
  const sorted = Array.from(heights).sort((a,b)=>a-b);
  const landThresh = sorted[Math.floor((1-LAND_TARGET)*sorted.length)] || 0.5;
  const landHeights = sorted.slice(sorted.length - Math.floor(LAND_TARGET*sorted.length));
  const mountThresh = landHeights[Math.floor((1-MOUNT_TARGET)*landHeights.length)] || 0.8;

  forEachCell((x,y)=>{
    const h = heights[idx(x,y)];
    if(h < landThresh) gridTerrain[idx(x,y)] = 0; // 바다
    else if(h < mountThresh) gridTerrain[idx(x,y)] = 1; // 평지
    else gridTerrain[idx(x,y)] = 2; // 산맥
  });

  postprocessTerrain();
  drawTerrain();
}

function postprocessTerrain(){
  // 연결요소 파악
  const landMask = new Uint8Array(W*H);
  forEachCell((x,y)=>{ landMask[idx(x,y)] = (gridTerrain[idx(x,y)]===0)?0:1; });
  const comps = connectedComponents(landMask, 1);

  // 작은 섬 확보(군도 바탕): 1~2칸 섬 목표
  const desiredTinyIslands = 6; let tinyCount = 0;
  comps.forEach(c=>{ if(c.cells.length<=2) tinyCount++; });
  const toAdd = Math.max(0, desiredTinyIslands - tinyCount);
  for(let t=0;t<toAdd;t++){
    for(let tries=0; tries<80; tries++){
      const x = randInt(rng, 1, W-2), y = randInt(rng, 1, H-2);
      if(gridTerrain[idx(x,y)]===0){
        const near = neighbors4(x,y);
        if(near.every(([a,b])=>gridTerrain[idx(a,b)]===0)){
          gridTerrain[idx(x,y)] = (rng()<0.2)? 2 : 1; // 가끔 암석섬
          break;
        }
      }
    }
  }

  addArchipelagoClusters(6);     // 군도 다발
  for(let k=0;k<12;k++) addPeninsula(); // 반도 다수
  addIsthmusBridges(8);          // 지협 메움
  carveStraits(8);               // 협곡 깎기
  addLandBridgeWide(4);          // 2칸 연결부
  for(let m=0;m<6;m++) addMountainRidge(); // 능선 강화
  tagIsthmusCells();
}

function connectedComponents(mask, pass=1){
  const seen = new Uint8Array(W*H); const comps = [];
  forEachCell((x,y)=>{
    const id = idx(x,y);
    if(!seen[id] && mask[id]===pass){
      const cells=[]; seen[id]=1; const q=[[x,y]];
      while(q.length){
        const [cx,cy]=q.pop(); cells.push([cx,cy]);
        neighbors4(cx,cy).forEach(([nx,ny])=>{
          const nid=idx(nx,ny);
          if(!seen[nid] && mask[nid]===pass){ seen[nid]=1; q.push([nx,ny]); }
        })
      }
      comps.push({cells});
    }
  })
  return comps;
}
function isCoast(x,y){ if(gridTerrain[idx(x,y)]===0) return false; return neighbors4(x,y).some(([a,b])=>gridTerrain[idx(a,b)]===0); }
function addPeninsula(){
  const coast = [];
  forEachCell((x,y)=>{ if(isCoast(x,y) && gridTerrain[idx(x,y)]!==2) coast.push([x,y]); });
  if(coast.length===0) return;
  const [sx,sy] = choice(rng, coast);
  const dirCand = neighbors4(sx,sy).filter(([a,b])=>gridTerrain[idx(a,b)]===0);
  if(dirCand.length===0) return;
  let [dx,dy] = choice(rng, dirCand).map((v,i)=>[v-(i?sy:sx)])[0]; // normalize
  dx = Math.sign(dx); dy = Math.sign(dy);
  let x=sx, y=sy; const len = randInt(rng,2,5);
  for(let i=0;i<len;i++){
    const nx=x+dx, ny=y+dy; if(!inside(nx,ny)) break;
    if(gridTerrain[idx(nx,ny)]===0){ gridTerrain[idx(nx,ny)] = 1; }
    x=nx; y=ny;
    if(rng()<0.4){
      const lx = nx - dy, ly = ny + dx; if(inside(lx,ly) && gridTerrain[idx(lx,ly)]===0 && rng()<0.6) gridTerrain[idx(lx,ly)]=1;
      const rx = nx + dy, ry = ny - dx; if(inside(rx,ry) && gridTerrain[idx(rx,ry)]===0 && rng()<0.6) gridTerrain[idx(rx,ry)]=1;
    }
  }
}
function addIsthmusBridges(maxBridges){ if(typeof maxBridges!=='number') maxBridges=6; let bridges=0; for(let tries=0; tries<200 && bridges<maxBridges; tries++){ const x = randInt(rng,1,W-2), y=randInt(rng,1,H-2); if(gridTerrain[idx(x,y)]!==0) continue; const up=gridTerrain[idx(x,y-1)]!==0, down=gridTerrain[idx(x,y+1)]!==0; const left=gridTerrain[idx(x-1,y)]!==0, right=gridTerrain[idx(x+1,y)]!==0; if((up&&down && !left && !right) || (left&&right && !up && !down)){ gridTerrain[idx(x,y)] = 1; bridges++; } } }
function carveStraits(maxCuts){ if(typeof maxCuts!=='number') maxCuts=6; let cuts=0; for(let tries=0; tries<240 && cuts<maxCuts; tries++){ const x = randInt(rng,1,W-2), y=randInt(rng,1,H-2); if(gridTerrain[idx(x,y)]===0) continue; const up=gridTerrain[idx(x,y-1)]!==0, down=gridTerrain[idx(x,y+1)]!==0; const left=gridTerrain[idx(x-1,y)]!==0, right=gridTerrain[idx(x+1,y)]!==0; if((up&&down&&!left&&!right) || (!up&&!down&&left&&right)){ if(rng()<0.3){ gridTerrain[idx(x,y)] = 0; cuts++; } } } }
function addLandBridgeWide(max=3){ let made=0; for(let tries=0; tries<300 && made<max; tries++){ const x = randInt(rng,2,W-3), y = randInt(rng,2,H-3); if(gridTerrain[idx(x-1,y)]!==0 && gridTerrain[idx(x,y)]===0 && gridTerrain[idx(x+1,y)]===0 && gridTerrain[idx(x+2,y)]!==0){ gridTerrain[idx(x,y)] = 1; gridTerrain[idx(x+1,y)] = 1; made++; continue; } if(gridTerrain[idx(x,y-1)]!==0 && gridTerrain[idx(x,y)]===0 && gridTerrain[idx(x,y+1)]===0 && gridTerrain[idx(x,y+2)]!==0){ gridTerrain[idx(x,y)] = 1; gridTerrain[idx(x,y+1)] = 1; made++; continue; } } }
function addMountainRidge(){ for(let tries=0; tries<50; tries++){ const x = randInt(rng,0,W-1), y=randInt(rng,0,H-1); if(gridTerrain[idx(x,y)]!==1) continue; let len = randInt(rng,8,16), cx=x, cy=y; let lastDir=null; while(len-->0){ gridTerrain[idx(cx,cy)] = 2; const opts = neighbors4(cx,cy).filter(([a,b])=>gridTerrain[idx(a,b)]!==0); if(opts.length===0) break; let [nx,ny] = choice(rng, opts); if(lastDir && rng()<0.5){ const tx = cx + (lastDir[0]-cx), ty = cy + (lastDir[1]-cy); if(inside(tx,ty) && gridTerrain[idx(tx,ty)]!==0){ nx=tx; ny=ty; } } lastDir=[nx,ny]; cx=nx; cy=ny; } break; } }
function tagIsthmusCells(){ forEachCell((x,y)=>{ const id=idx(x,y); if(gridTerrain[id]===0) { isIsthmus[id]=0; return; } const up = gridTerrain[idx(x,y-1)]!==0, down=gridTerrain[idx(x,y+1)]!==0; const left = gridTerrain[idx(x-1,y)]!==0, right=gridTerrain[idx(x+1,y)]!==0; if((up&&down && !left && !right) || (left&&right && !up && !down)) isIsthmus[id]=1; else isIsthmus[id]=0; }); }
function distanceToLand(x,y,maxd=6){
  for(let d=1; d<=maxd; d++){
    for(let dx=-d; dx<=d; dx++){
      const dy1 = d - Math.abs(dx);
      for(const dy of [dy1, -dy1]){
        const ax = x+dx, ay = y+dy; if(!inside(ax,ay)) continue;
        if(gridTerrain[idx(ax,ay)]!==0) return d; // 육지 발견
      }
    }
  }
  return Infinity;
}

function addArchipelagoClusters(count=5){
  for(let c=0;c<count;c++){
    // 바다이면서 육지와 2~6칸 거리인 지점을 찾음 (대륙 근처)
    let found=false, cx=0, cy=0;
    for(let tries=0; tries<120; tries++){
      const x = randInt(rng,2,W-3), y = randInt(rng,2,H-3);
      if(gridTerrain[idx(x,y)]!==0) continue;
      const d = distanceToLand(x,y,6);
      if(d>=2 && d<=6){ cx=x; cy=y; found=true; break; }
    }
    if(!found) continue;

    // 이 클러스터에서 2~4개의 섬 블롭을 생성, 각 4~10칸 정도
    const blobN = randInt(rng,2,4);
    const newCellsCluster = new Set();
    for(let b=0;b<blobN;b++){
      const ang = rng()*Math.PI*2; const rad = randInt(rng,2,4);
      const sx = Math.max(1, Math.min(W-2, cx + Math.round(Math.cos(ang)*rad)));
      const sy = Math.max(1, Math.min(H-2, cy + Math.round(Math.sin(ang)*rad)));
      if(gridTerrain[idx(sx,sy)]!==0) continue;
      // 시드가 기존 육지에 붙지 않도록 1칸 버퍼 확인
      const nearLand = neighbors4(sx,sy).some(([nx,ny])=> gridTerrain[idx(nx,ny)]!==0);
      if(nearLand) continue;

      const target = randInt(rng,4,10);
      const q=[[sx,sy]]; const seen=new Set([idx(sx,sy)]);
      let made=0;
      while(q.length && made<target){
        const [x,y]=q.shift(); const idg=idx(x,y);
        // 주변에 '기존 육지'가 붙어있는지 확인 (새로 만든 셀은 허용)
        const touchesOldLand = neighbors4(x,y).some(([nx,ny])=>{
          const nid=idx(nx,ny);
          return gridTerrain[nid]!==0 && !newCellsCluster.has(nid);
        });
        if(!touchesOldLand && gridTerrain[idg]===0){
          gridTerrain[idg] = rng()<0.12? 2 : 1; // 가끔 산봉우리
          newCellsCluster.add(idg);
          made++;
          // 확장 후보 추가 (바다이고 경계 내)
          neighbors4(x,y).forEach(([nx,ny])=>{
            const nid=idx(nx,ny);
            if(!seen.has(nid) && gridTerrain[nid]===0){ seen.add(nid); q.push([nx,ny]); }
          });
        }
      }
    }
  }
}
function centroidOf(c){ let sx=0, sy=0, n=0; c.cells.forEach(g=>{ sx += (g%W)+0.5; sy += ((g/W)|0)+0.5; n++; }); if(n===0) return [0,0]; return [ (sx/n)*CELL, (sy/n)*CELL ]; }

// ====== 렌더: 지형 ======
function drawTerrain(){
  if(!terr) return;
  terr.clearRect(0,0,terrainCV.width, terrainCV.height);
  forEachCell((x,y)=>{
    const t = gridTerrain[idx(x,y)];
    terr.fillStyle = t===0 ? getCSS('--sea') : (t===1 ? getCSS('--land') : getCSS('--mount'));
    terr.fillRect(x*CELL, y*CELL, CELL, CELL);
  });
}

// makeName 가드: 누락 시 최소 이름 생성기 주입
if (typeof makeName !== 'function') {
  function makeName(){
    const pre=['Ar','Bel','Cal','Den','Eri','Fal','Gar','Hel','Ira','Jun','Kar','Lys','Mor','Nor','Or','Pra','Qua','Ryn','Syl','Tor','Ulf','Val','Wes','Xan','Yor','Zer'];
    const mid=['a','e','i','o','u','y','ae','ia','oa','ui'];
    const suf=['land','ia','stan','ara','ora','eria','nor','gard','heim','veen','mere','vale','reach','shore','mar','lia'];
    const syll = 2 + Math.floor(rng()*2);
    let name = pre[randInt(rng,0,pre.length-1)];
    for(let i=0;i<syll-1;i++){ name += mid[randInt(rng,0,mid.length-1)]; if(rng()<0.6) name += String.fromCharCode(97+Math.floor(rng()*26)); }
    name += suf[randInt(rng,0,suf.length-1)];
    return name;
  }
}

// === 섬/군도 초기 편입(가까운 육지 국가에 합류; 작은 국가 우대) ===
function annexIslandsNearMainland(maxSeaGap=3){
  // 1) 육지 컴포넌트 계산
  const landMask = new Uint8Array(W*H);
  forEachCell((x,y)=>{ landMask[idx(x,y)] = (gridTerrain[idx(x,y)]===0)?0:1; });
  const comps = connectedComponents(landMask, 1);
  const compOf = new Int32Array(W*H).fill(-1);
  let totalLand = 0;
  comps.forEach((c,i)=>{ c.size=c.cells.length; totalLand += c.size; c.cells.forEach(([x,y])=>{ compOf[idx(x,y)]=i; }); });
  const mainlandThresh = Math.max(40, Math.floor(totalLand * 0.02)); // 대략 육지의 ≥2%
  const isMainland = comps.map(c=> c.size >= mainlandThresh);

  // 2) 각 섬(비-메인랜드)에서 인접 육지 국가 후보 수집 (바다 최대 maxSeaGap칸 건너)
  const sizeMap = new Map(); C.forEach(c=> sizeMap.set(c.id, c.cells.size));

  comps.forEach((comp, ci)=>{
    if(isMainland[ci]) return; // 섬/군도만 처리
    const candidates = new Map(); // countryId -> weight
    for(const [x,y] of comp.cells){
      const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
      for(const [dx,dy] of dirs){
        let nx=x+dx, ny=y+dy, gap=0;
        while(inside(nx,ny) && gap<maxSeaGap){
          const t = gridTerrain[idx(nx,ny)];
          if(t===0){ gap++; nx+=dx; ny+=dy; continue; }
          const otherCI = compOf[idx(nx,ny)];
          if(otherCI!==ci && isMainland[otherCI]){
            const cid = gridCountry[idx(nx,ny)];
            if(cid>=0){
              const sz = (sizeMap.get(cid)||1);
              const w = 1/Math.pow(sz,0.7); // 작은 나라 우대
              candidates.set(cid, (candidates.get(cid)||0) + w);
            }
          }
          break; // 첫 육지에서 종료
        }
      }
    }
    if(candidates.size===0) return;
    // 가중치 랜덤 선택
    let sum=0; candidates.forEach(v=> sum+=v);
    let r = rng()*sum; let targetId=null;
    for(const [cid,w] of candidates){ r-=w; if(r<=0){ targetId=cid; break; } }
    if(targetId==null) targetId = candidates.keys().next().value;

    // 3) 섬 전체를 대상 국가에 편입
    const target = C.find(k=>k.id===targetId);
    if(!target) return;
    comp.cells.forEach(([x,y])=>{
      const g = idx(x,y);
      const prev = gridCountry[g];
      if(prev===targetId) return;
      if(prev>=0){ const pv=C.find(k=>k.id===prev); if(pv) pv.cells.delete(g); }
      gridCountry[g]=targetId; target.cells.add(g);
    });
  });
}

function seedCountries(){
  const landCells = []; forEachCell((x,y)=>{ if(gridTerrain[idx(x,y)]!==0) landCells.push([x,y]); });
  const L = landCells.length; const targetCountries = Math.max(6, Math.min(20, Math.floor(L/20)));
  C = []; gridCountry.fill(-1); colors = makePalette(targetCountries, rng);

  // 씨앗 배치
  const chosen=[];
  for(let i=0;i<targetCountries;i++){
    for(let tries=0; tries<100; tries++){
      const [x,y] = choice(rng, landCells);
      if(chosen.every(([ax,ay])=> (Math.abs(ax-x)+Math.abs(ay-y))>4)) { chosen.push([x,y]); break; }
    }
  }
  chosen.forEach(([x,y], id)=>{ C.push({ id, cells: new Set([idx(x,y)]), s: 0.7 + rng()*0.2, neighbors: new Set(), tag:{}, name: makeName() }); gridCountry[idx(x,y)]=id; });

  // 멀티-씨앗 확장
  const frontier = []; chosen.forEach(([x,y], id)=>{ neighbors4(x,y).forEach(([a,b])=> frontier.push([a,b,id])); });
  while(frontier.length){
    const i = randInt(rng,0,frontier.length-1); const [x,y,id] = frontier.splice(i,1)[0]; const gid = idx(x,y);
    if(gridTerrain[gid]===0 || gridCountry[gid]!==-1) continue;
    gridCountry[gid] = id; C[id].cells.add(gid);
    neighbors4(x,y).forEach(([a,b])=> frontier.push([a,b,id]));
  }

  // 태그
  C.forEach(c=>{ let mount=0, coast=0; c.cells.forEach(g=>{ if(gridTerrain[g]===2) mount++; const x=g%W,y=(g/W)|0; if(isCoast(x,y)) coast++; }); c.tag.mountRatio = mount/Math.max(1,c.cells.size); c.tag.coastRatio = coast/Math.max(1,c.cells.size); });
  // 섬/군도 초기 편입 실행 (육지로부터 3칸 이내)
  annexIslandsNearMainland(3);
  reindexCountries();
  rebuildNeighborsAll();
}

function rebuildNeighborsAll(){
  C.forEach(c=>c.neighbors.clear());
  forEachCell((x,y)=>{ const a = gridCountry[idx(x,y)]; if(a<0) return; neighbors4(x,y).forEach(([nx,ny])=>{ const b = gridCountry[idx(nx,ny)]; if(b>=0 && b!==a){ C[a].neighbors.add(b); C[b].neighbors.add(a); } }) });
  borderEdges = collectBorders();
  const have = new Set(borderEdges.map(e=> e.a+"-"+e.b));
  const seaEdges = collectMaritimeBorders(3);
  seaEdges.forEach(e=>{ const key=e.a+"-"+e.b; if(!have.has(key)){ borderEdges.push(e); have.add(key); }});
  borderEdges.forEach(e=>{ const A=C[e.a], B=C[e.b]; if(A&&B){ A.neighbors.add(B.id); B.neighbors.add(A.id); }});
}

function collectBorders(){
  const map = new Map();
  forEachCell((x,y)=>{
    const a = gridCountry[idx(x,y)]; if(a<0) return;
    [[1,0],[0,1]].forEach(([dx,dy])=>{
      const nx=x+dx, ny=y+dy; if(!inside(nx,ny)) return; const b = gridCountry[idx(nx,ny)];
      if(b>=0 && b!==a){ const lo=Math.min(a,b), hi=Math.max(a,b); const key=lo+"-"+hi; if(!map.has(key)) map.set(key,{a:lo,b:hi,cells:[],type:null}); map.get(key).cells.push([x,y,nx,ny]); }
    })
  });
  map.forEach(entry=>{ let mount=0, neck=0; entry.cells.forEach(([x,y,nx,ny])=>{ const t1 = gridTerrain[idx(x,y)], t2 = gridTerrain[idx(nx,ny)]; if(t1===2 || t2===2) mount++; if(isIsthmus[idx(x,y)]||isIsthmus[idx(nx,ny)]) neck++; }); if(neck/entry.cells.length > 0.3) entry.type='isthmus'; else if(mount/entry.cells.length > 0.2) entry.type='mount'; else entry.type='plain'; });
  return Array.from(map.values());
}

function collectMaritimeBorders(maxGap=3){
  const map = new Map();
  forEachCell((x,y)=>{
    const a = gridCountry[idx(x,y)]; if(a<0) return; if(!isCoast(x,y)) return;
    const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
    for(const [dx,dy] of dirs){
      let nx=x+dx, ny=y+dy, gap=0;
      while(inside(nx,ny) && gap<maxGap){
        const t = gridTerrain[idx(nx,ny)];
        if(t===0){ gap++; nx+=dx; ny+=dy; continue; }
        const b = gridCountry[idx(nx,ny)];
        if(b>=0 && b!==a){ const lo=Math.min(a,b), hi=Math.max(a,b); const key = lo+"-"+hi+"-sea"; if(!map.has(key)) map.set(key,{a:lo,b:hi,cells:[],type:'sea'}); map.get(key).cells.push([x,y,nx,ny]); }
        break;
      }
    }
  });
  return Array.from(map.values());
}

// ====== 렌더 ======
function drawCountries(){
  ctx.clearRect(0,0,countryCV.width,countryCV.height);
  C.forEach(c=>{ ctx.fillStyle = colors[c.id % colors.length]; c.cells.forEach(g=>{ const x=g%W, y=(g/W)|0; ctx.fillRect(x*CELL, y*CELL, CELL, CELL); }); });
  // 하이라이트
  const now = Date.now(); highlights = highlights.filter(h=> now - h.t < 1000); ctx.globalAlpha=0.8; ctx.fillStyle=getCSS('--hit');
  highlights.forEach(h=>{ const a=1-(now-h.t)/1000; ctx.globalAlpha=0.2+0.6*a; ctx.fillRect(h.x*CELL, h.y*CELL, CELL, CELL); }); ctx.globalAlpha=1;
  // 라벨
  ctx.save(); ctx.textAlign='center'; ctx.textBaseline='middle';
  C.forEach(c=>{ const [px,py]=centroidOf(c); const sz=c.cells.size; const fontSize = Math.max(10, Math.min(22, 8 + Math.sqrt(sz)*1.2)); ctx.font='bold '+fontSize+'px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Noto Sans'; ctx.lineWidth=3; ctx.strokeStyle='rgba(0,0,0,0.7)'; ctx.strokeText(c.name, px, py); ctx.fillStyle='#ffffff'; ctx.fillText(c.name, px, py); });
  ctx.restore();
}

function borderMod(entry){ switch(entry.type){ case 'mount': return 0.5; case 'isthmus': return 1.7; case 'sea': return 0.20; default: return 1.0; } }
function defenseMod(entry){ switch(entry.type){ case 'mount': return 1.4; case 'isthmus': return 1.3; case 'sea': return 1.0; default: return 1.0; } }

// ====== 시뮬 루프 ======
let tickHandle=null, stepDelay=250; // 1x → 4턴/초
function setSpeed(v){ speed=v; document.getElementById('speedOut').textContent=v+'×'; stepDelay = 250 / v; if(!paused){ clearInterval(tickHandle); tickHandle = setInterval(step, stepDelay); } }
function pushTicker(html){ const line=document.createElement('div'); line.innerHTML=html; const t=document.getElementById('ticker'); t.prepend(line); while(t.childElementCount>60) t.lastChild.remove(); }
function metricG(){ const sizes=C.map(c=>c.cells.size).sort((a,b)=>b-a); const total=sizes.reduce((p,c)=>p+c,0)||1; return sizes.length?(sizes[0]/total):0; }
function adjustTension(){ const E10 = eventScoreRing.reduce((p,c)=>p+c,0); const targetLo=18, targetHi=22; if(E10 < targetLo){ T = Math.min(1.5, T * 1.1); } else if(E10 > targetHi){ T = Math.max(0.8, T * 0.9); } else { T += (1.0 - T)*0.05; } }

function step(){ if(paused) return; if(!Array.isArray(C) || C.length===0){ return; } if(!Array.isArray(borderEdges)) { rebuildNeighborsAll(); } turn++; let eScore=0; const med = median(C.length ? C.map(c=>c.cells.size) : [0]); const G = C.length ? metricG() : 0;
  // 안정도 자연 변화
  C.forEach(c=>{ c.s -= 0.01 * Math.log(1 + c.cells.size / Math.max(1,med)); if(G>0.38 && c.cells.size === maxSize()) c.s -= 0.02; c.s += 0.02; c.s = clamp(c.s,0,1); });
  // 전쟁 샘플링
  if(borderEdges && borderEdges.length){ const samples = Math.min(12, borderEdges.length); for(let k=0;k<samples;k++){ const entry = borderEdges[randInt(rng,0,borderEdges.length-1)]; const a = C.find(c=>c && c.id===entry.a), b = C.find(c=>c && c.id===entry.b); if(!a||!b) continue; const larger = a.cells.size>=b.cells.size? a:b; const smaller = (larger===a)? b:a; const modB = borderMod(entry); const base = W0 * T * modB * (1 + Math.max(0, Math.log(larger.cells.size / Math.max(1, smaller.cells.size)))) * (0.5 + 0.5*frontierRatio(larger)) * (1 - 0.3*smaller.s); const p = Math.min(MAX_P_WAR, base); if(rng()<p){ let A_terr=1.0; if(entry.type==='mount') A_terr=0.8; else if(entry.type==='isthmus') A_terr=1.1; else if(entry.type==='sea') A_terr=0.50; const D_def = defenseMod(entry); const F_att = Math.pow(larger.cells.size,0.6)*Math.pow(Math.max(0.1,larger.s),0.4)*A_terr*sampleLogNormal(rng,0.35); const F_def = Math.pow(smaller.cells.size,0.6)*Math.pow(Math.max(0.1,smaller.s),0.4)*D_def*sampleLogNormal(rng,0.35); const attacker=larger, defender=smaller; if(F_att>F_def){ const want = Math.floor(Math.min(12, Math.max(1, samplePareto(rng,1.8,1)))); const taken = seizeBorder(attacker, defender, entry, want); if(taken>0){ attacker.s += 0.03; defender.s -= 0.10; attacker.s=clamp(attacker.s,0,1); defender.s=clamp(defender.s,0,1); eScore += 1; pushTicker(`⚔ <b>전쟁</b> — <span style="color:${colors[attacker.id]}">국가${attacker.id}</span> → <span style="color:${colors[defender.id]}">국가${defender.id}</span> (${taken}칸)`); } } else { defender.s += 0.02; attacker.s -= 0.02; } } } }
  // 반란
  const evalCount = Math.min(8, C.length); for(let i=0;i<evalCount;i++){ const c = choice(rng, C); if(!c) continue; const R_terr = 1 + 0.5*c.tag.mountRatio + 0.2*Math.min(0.8,c.tag.coastRatio); const p = clamp(R0 * T * R_terr * Math.pow(c.cells.size/Math.max(1,med),0.7) * Math.pow(1-c.s,1.2), 0, MAX_P_REB); if(rng()<p && c.cells.size>=6){ const out = splitRebellion(c); if(out){ eScore += 1.5; pushTicker(`⚑ <b>반란</b> — 국가${c.id}에서 신생국 <span style="color:${colors[out.id]}">국가${out.id}</span> 등장 (${out.cells.size}칸)`); } } }
  // 연합합병
  if(turn%7===0){ const gShare = metricG(); if(gShare>=0.25){ const merged = tryUnionMerge(gShare); if(merged>0){ eScore += 2; pushTicker(`⛬ <b>연합</b> — 소국 ${merged}개가 연합하여 강자 견제`); } } }
  // 멸망 정리
  C = C.filter(c=>c && c.cells.size>0); reindexCountries(); rebuildNeighborsAll();
  // 페이싱
  eventScoreRing.unshift(eScore); if(eventScoreRing.length>10) eventScoreRing.pop(); adjustTension();
  // 스파크라인
  const N=C.length, Gv=metricG(); Nspark.push(N); if(Nspark.length>100) Nspark.shift(); Gspark.push(Gv); if(Gspark.length>100) Gspark.shift(); drawSparks();
  // 렌더
  drawCountries(); updateRank(); document.getElementById('turnOut').textContent=String(turn);
}

function seizeBorder(att, def, entry, want){
  const q = [];
  entry.cells.forEach(([x,y,nx,ny])=>{ if(gridCountry[idx(x,y)]===def.id) q.push([x,y]); if(gridCountry[idx(nx,ny)]===def.id) q.push([nx,ny]); });
  const seen = new Set(); let taken=0;
  while(q.length && taken<want){ const i = randInt(rng,0,q.length-1); const [x,y] = q.splice(i,1)[0]; const gid=idx(x,y); if(gridCountry[gid]!==def.id || seen.has(gid)) continue; seen.add(gid); if(gridTerrain[gid]===2 && rng()<0.4) { continue; } gridCountry[gid]=att.id; att.cells.add(gid); def.cells.delete(gid); highlights.push({x,y,t:Date.now()}); taken++; neighbors4(x,y).forEach(([a,b])=>{ if(gridCountry[idx(a,b)]===def.id) q.push([a,b]); }); }
  return taken;
}

function splitRebellion(c){ const size=c.cells.size; const target=Math.max(3, Math.floor(size*(0.2+0.2*rng()))); const cells=Array.from(c.cells); const weighted=cells.map(g=>{ const x=g%W,y=(g/W)|0; const coast=isCoast(x,y)?1:0; const mount=(gridTerrain[g]===2)?1:0; return {g, w: 1 + 1.5*mount + 0.6*coast}; }); let start=weighted[0]?.g; if(weighted.length){ let sum=weighted.reduce((p,o)=>p+o.w,0), r=rng()*sum; for(const o of weighted){ r-=o.w; if(r<=0){ start=o.g; break; } } } const startX=start%W, startY=(start/W)|0; const out=new Set(); const q=[[startX,startY]]; const seen=new Set([start]); while(q.length && out.size<target){ const [x,y]=q.shift(); const gid=idx(x,y); if(gridCountry[gid]!==c.id) continue; out.add(gid); const nbr=neighbors4(x,y).sort(()=>rng()-0.5); nbr.forEach(([a,b])=>{ const id=idx(a,b); if(!seen.has(id) && gridCountry[id]===c.id){ seen.add(id); q.push([a,b]); } }); } if(out.size<3) return null; const newId=C.length; const s0=0.55 + rng()*0.2; const newC={ id:newId, cells:new Set(out), s:s0, neighbors:new Set(), tag:{}, name: makeName() }; out.forEach(g=>{ gridCountry[g]=newId; c.cells.delete(g); const x=g%W,y=(g/W)|0; highlights.push({x,y,t:Date.now()}); }); C.push(newC); colors[newId] = colors[newId] || hslToHex((rng()*360), 70, 55); let mount=0, coast=0; newC.cells.forEach(g=>{ if(gridTerrain[g]===2) mount++; const x=g%W,y=(g/W)|0; if(isCoast(x,y)) coast++; }); newC.tag.mountRatio = mount/Math.max(1,newC.cells.size); newC.tag.coastRatio = coast/Math.max(1,newC.cells.size); return newC; }

function tryUnionMerge(Gshare){ const med = median(C.map(c=>c.cells.size)); const small = C.filter(c=>c.cells.size <= Math.max(2, Math.floor(med/2))); if(small.length<3) return 0; const idToIdx = new Map(); small.forEach((c,i)=>idToIdx.set(c.id,i)); const seen=new Set(); let mergedCount=0; for(const s of small){ if(seen.has(s.id)) continue; const comp=[s]; seen.add(s.id); const q=[s]; while(q.length){ const cur=q.shift(); cur.neighbors.forEach(nid=>{ if(idToIdx.has(nid) && !seen.has(nid)){ seen.add(nid); const nc=C.find(x=>x.id===nid); if(nc){ comp.push(nc); q.push(nc); } } }) } if(comp.length>=3){ let borders=0, possible=0; comp.forEach(a=>comp.forEach(b=>{ if(a!==b){ possible++; if(a.neighbors.has(b.id)) borders++; }})); const cohesion = possible? (borders/possible) : 0.5; const p = clamp(U0 * T * Math.pow(Gshare-0.25,1.1) * (comp.length/3) * (0.8 + 0.6*cohesion), 0, 0.6); if(rng()<p){ const base=comp[0]; for(let i=1;i<comp.length;i++){ const victim=comp[i]; victim.cells.forEach(g=>{ gridCountry[g]=base.id; base.cells.add(g); const x=g%W,y=(g/W)|0; highlights.push({x,y,t:Date.now()}); }); victim.cells.clear(); } base.s = clamp((base.s + 0.1), 0, 1); mergedCount = comp.length; break; } } } return mergedCount; }

function reindexCountries(){ const alive=C.filter(c=>c.cells.size>0); const mapId=new Map(alive.map((c,i)=>[c.id,i])); alive.forEach((c,i)=>{ c.id=i; }); forEachCell((x,y)=>{ const g=gridCountry[idx(x,y)]; if(g>=0) gridCountry[idx(x,y)] = mapId.get(g); }); const newColors=[]; alive.forEach(c=>{ newColors[c.id] = colors[c.id] || colors[mapId.get(c.id)] || hslToHex(rng()*360,70,55); }); colors=newColors; C=alive; }

function drawSparks(){ const draw=(g,arr,color)=>{ g.clearRect(0,0,g.canvas.width,g.canvas.height); const w=g.canvas.width,h=g.canvas.height; if(arr.length<2) return; const min=Math.min(...arr), max=Math.max(...arr); const pad=4; g.beginPath(); for(let i=0;i<arr.length;i++){ const x=pad+(w-2*pad)*i/(arr.length-1); const norm=(arr[i]-min)/Math.max(1e-6,(max-min)); const y=h-pad-(h-2*pad)*norm; if(i===0) g.moveTo(x,y); else g.lineTo(x,y); } g.strokeStyle=color; g.lineWidth=1.5; g.stroke(); }
  draw(sparkN, Nspark, '#87f291'); draw(sparkG, Gspark, '#f2cd87'); }

function escapeHTML(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
function updateRank(){
  const box = document.getElementById('rank'); if(!box) return;
  if(!Array.isArray(C) || C.length===0){ box.innerHTML=''; return; }
  const top = C.map(c=>({ name:c.name, size:c.cells.size, color: colors[c.id % colors.length] }))
               .sort((a,b)=>b.size-a.size).slice(0,5);
  box.innerHTML = top.map((o,i)=>
    `<div class="item"><span style="color:#9dc6ff;width:1.2em;text-align:right;display:inline-block">${i+1}.</span>
      <span class="name" style="color:${o.color}">${escapeHTML(o.name)}</span>
      <span style="opacity:.8">${o.size}</span></div>`
  ).join('');
}

// ====== 부트스트랩 ======
function restart(){ seed = (Math.random()*0xffffffff)>>>0; rng = mulberry32(seed); document.getElementById('seedOut').textContent = seed.toString(16).padStart(8,'0'); turn=0; T=1.0; eventScoreRing=[]; Nspark=[]; Gspark=[]; highlights=[]; document.getElementById('ticker').innerHTML=''; generateMap();
  seedCountries();
  // 초기 편입은 seed 이후 한 번 더 보장
  annexIslandsNearMainland(3);
  reindexCountries();
  rebuildNeighborsAll();
  drawCountries(); updateRank(); }

const pauseBtn = document.getElementById('pauseBtn');
const resumeBtn = document.getElementById('resumeBtn');
const restartBtn = document.getElementById('restartBtn');
const speedSel = document.getElementById('speed');
pauseBtn.addEventListener('click', ()=>{ paused=true; pauseBtn.disabled=true; resumeBtn.disabled=false; });
resumeBtn.addEventListener('click', ()=>{ paused=false; pauseBtn.disabled=false; resumeBtn.disabled=true; });
restartBtn.addEventListener('click', ()=>{ restart(); });
speedSel.addEventListener('change', (e)=>{ setSpeed(parseFloat(e.target.value)); });

restart(); setSpeed(1); paused=false; clearInterval(tickHandle); tickHandle = setInterval(step, stepDelay);
</script>
</body>
</html>
