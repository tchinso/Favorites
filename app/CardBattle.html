<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ì†ì„± ì¹´ë“œ ë°°í‹€ Â· í”„ë¡œí† íƒ€ì… v1</title>
  <style>
    :root{
      --bg:#0f1115; --panel:#161a22; --panel-2:#1c2230; --text:#e6edf3; --muted:#9fb0c0; --accent:#7aa2f7; --danger:#ff5d62; --ok:#8bd5a1;
      --card-w: 210px; --card-h: 170px; --radius:16px;
      --fire:#ff7f27; --ice:#87cefa; --volt:#ffd700; --wind:#98fb98; --slash:#c2a14a; --strike:#6b7a8f; --pierce:#8b3a3a;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0; background:linear-gradient(180deg,#0c1016,#0f1219 25%,#0f1115); color:var(--text); font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,"Apple SD Gothic Neo","Noto Sans KR",sans-serif}
    h1{margin:10px 0 4px; font-size:20px; font-weight:700}
    .wrap{max-width:1200px; margin:0 auto; padding:16px}
    .row{display:grid; gap:12px; grid-template-columns:repeat(3, 1fr); margin:8px 0 18px}
    .side-title{display:flex; align-items:center; gap:8px; color:var(--muted); font-size:14px; letter-spacing:.2px}
    .legend{display:flex; flex-wrap:wrap; gap:8px; margin:6px 0 12px}
    .pill{display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border-radius:999px; font-size:12px; background:var(--panel-2); color:var(--text); border:1px solid #2a3446}
    .pill .ico{font-size:14px}

    .board{display:flex; flex-direction:column; gap:8px}
    .card{position:relative; background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0)); border:1px solid #2a3446; border-radius:var(--radius); padding:10px; min-height:var(--card-h); cursor:pointer; transition:transform .15s ease, box-shadow .2s ease, border-color .2s ease; user-select:none}
    .card:hover{transform:translateY(-2px)}
    .card.dead{opacity:.35; filter:grayscale(60%); cursor:not-allowed}
    .card.inactive{opacity:.55; cursor:not-allowed}
    .card.selected{outline:2px solid var(--accent); box-shadow:0 0 0 6px rgba(122,162,247,.18) inset}
    .card.enemy{background:linear-gradient(180deg, rgba(255,255,255,0.015), rgba(255,255,255,0));}
    .card .top{display:flex; gap:8px; align-items:center; justify-content:space-between}
    .role{display:inline-flex; align-items:center; gap:6px; padding:2px 8px; border-radius:999px; border:1px solid #2a3446; background:rgba(255,255,255,0.03); font-size:12px}
    .hp{font-variant-numeric:tabular-nums; font-weight:700}
    .bar{height:8px; border-radius:999px; background:#2a3446; overflow:hidden; margin:6px 0 2px}
    .bar>i{display:block; height:100%; background:linear-gradient(90deg, #7ee787, #2ea043); width:100%}
    .attrs{display:flex; gap:8px; margin-top:8px}
    .attr{display:flex; align-items:center; gap:6px; padding:4px 8px; border-radius:10px; font-size:12px; border:1px solid #2a3446; background:rgba(255,255,255,0.03)}
    .attr .ico{width:18px; height:18px; display:inline-flex; align-items:center; justify-content:center; border-radius:6px; color:#0f1115; font-weight:900}
    .attr.fire .ico{background:var(--fire)}
    .attr.ice .ico{background:var(--ice)}
    .attr.volt .ico{background:var(--volt)}
    .attr.wind .ico{background:var(--wind)}
    .attr.slash .ico{background:var(--slash)}
    .attr.strike .ico{background:var(--strike); color:#f2f2f2}
    .attr.pierce .ico{background:var(--pierce); color:#f2f2f2}
    .badges{display:flex; gap:6px; position:absolute; right:8px; bottom:8px}
    .badge{font-size:11px; padding:3px 6px; border-radius:8px; border:1px solid #2a3446; color:var(--muted)}
    .badge.stun{border-color:#665b00; background:rgba(255,215,0,.12); color:#ffd700}

    .controls{display:flex; flex-wrap:wrap; gap:10px; align-items:center; padding:10px; border-radius:12px; background:var(--panel); border:1px solid #2a3446}
    .btn{appearance:none; background:#22304a; color:#d6e1f3; border:1px solid #2a3446; padding:10px 14px; border-radius:10px; cursor:pointer; font-weight:700; transition:background .2s,border-color .2s,transform .04s}
    .btn:hover{background:#2a3a55}
    .btn:active{transform:translateY(1px)}
    .btn.ghost{background:transparent}
    .btn.green{background:#1e4d3a; border-color:#2c6e55}
    .btn.red{background:#4d1e1e; border-color:#6e2c2c}
    .btn.yellow{background:#4d441e; border-color:#6e5d2c}

    .status{padding:10px 12px; border-radius:10px; background:var(--panel); border:1px solid #2a3446; color:var(--muted)}
    .log{height:140px; overflow:auto; background:var(--panel); border:1px solid #2a3446; border-radius:12px; padding:10px; font-size:13px}
    .log p{margin:0 0 6px; color:#cdd7e3}

    .modal{position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,.55); z-index:40}
    .modal.open{display:flex}
    .modal .box{width:min(560px, calc(100% - 24px)); background:var(--panel-2); border:1px solid #2a3446; border-radius:16px; padding:16px}
    .modal h3{margin:4px 0 8px}
    .modal .options{display:flex; flex-wrap:wrap; gap:8px}
    .small{font-size:12px; color:var(--muted)}

    .footer{display:flex; align-items:center; justify-content:space-between; margin-top:14px}

    .hint{font-size:12px; color:#aebad0}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>ì†ì„± ì¹´ë“œ ë°°í‹€ Â· í”„ë¡œí† íƒ€ì… v1</h1>
    <div class="legend" id="legend"></div>

    <div class="board">
      <div class="side-title">ì  ë± (AI) Â· ìœ„ìª½</div>
      <div class="row" id="aiRow"></div>
      <div class="side-title">ì•„êµ° ë± (í”Œë ˆì´ì–´) Â· ì•„ë˜ìª½</div>
      <div class="row" id="playerRow"></div>
    </div>

    <div class="controls">
      <div id="turnInfo">ë‚´ í„´: ê³µê²© ì¹´ë“œì™€ ëŒ€ìƒ ì¹´ë“œë¥¼ ìˆœì„œëŒ€ë¡œ í´ë¦­</div>
      <button class="btn ghost" id="skipBtn" title="í…ŒìŠ¤íŠ¸ìš©">ìŠ¤í‚µ</button>
      <div class="hint">ê·œì¹™ ìš”ì•½: ì €í•­=0, ì¤‘ë¦½=10, ì·¨ì•½=45, ì–´íƒœì»¤ëŠ” 2ë°°. ë¸Œë ˆì´ì»¤ëŠ” ëŒ€ìƒì—ê²Œ ê³µê²©ë¶ˆê°€(ì·¨ì•½ì´ë©´ 2í„´). ì‰´ë”ëŠ” 200 HP, ëŒ€ì‹  ë§ê¸° ê°€ëŠ¥. ë¸Œë ˆì´ì»¤ê°€ ì‰´ë”ë¥¼ ë•Œë¦¬ë©´ì„œ ê³µê²©ì†ì„±ì´ ì‰´ë”ì˜ ì €í•­ì´ ì•„ë‹ˆë©´ 135 ê³ ì • í”¼í•´.</div>
    </div>

    <div class="status" id="status"></div>

    <div style="display:grid; grid-template-columns:1fr 320px; gap:12px; margin-top:12px">
      <div class="log" id="log"></div>
      <div>
        <button class="btn green" id="restartBtn">ë‹¤ì‹œ ì‹œì‘</button>
        <div class="small" style="margin-top:8px">íŒ: ë‚´ í„´ì— íëŸ¬ë¥¼ ì“°ë©´ ê³µê²© í›„ íšŒë³µ ëŒ€ìƒì„ ì•„ë˜ì—ì„œ í´ë¦­í•˜ë¼ëŠ” ì•ˆë‚´ê°€ ë– ìš”. ì  í„´ì—ëŠ” ë°©ì–´ íŒì—…ì—ì„œ ì‰´ë”ë¥¼ ì„ íƒí•´ ë§‰ì„ ìˆ˜ ìˆì–´ìš”.</div>
      </div>
    </div>
  </div>

  <!-- ë°©ì–´(ì‰´ë“œ) ì„ íƒ ëª¨ë‹¬ -->
  <div class="modal" id="shieldModal" role="dialog" aria-modal="true">
    <div class="box">
      <h3>ë°©ì–´ ì„ íƒ</h3>
      <p id="shieldText"></p>
      <div class="options" id="shieldOptions"></div>
      <div class="footer">
        <button class="btn" id="noShieldBtn">ì‰´ë“œí•˜ì§€ ì•Šê¸°</button>
        <button class="btn ghost" id="closeShieldBtn">ë‹«ê¸°</button>
      </div>
    </div>
  </div>

  <script>
    // ====== ë°ì´í„° ì •ì˜ ======
    const ATTRS = [
      {key:'í™”', code:'fire', name:'Fire', ico:'\uD83D\uDD25', color:'var(--fire)'},
      {key:'ë¹™', code:'ice', name:'Ice', ico:'\u2744\uFE0F', color:'var(--ice)'},
      {key:'ë‡Œ', code:'volt', name:'Volt', ico:'\u26A1\uFE0F', color:'var(--volt)'},
      {key:'í’', code:'wind', name:'Wind', ico:'\uD83C\uDF43', color:'var(--wind)'},
      {key:'ì°¸', code:'slash', name:'Slash', ico:'\uD83D\uDDE1\uFE0F', color:'var(--slash)'},
      {key:'íƒ€', code:'strike', name:'Strike', ico:'\uD83D\uDD28', color:'var(--strike)'},
      {key:'ëŒ', code:'pierce', name:'Pierce', ico:'\uD83D\uDCA3', color:'var(--pierce)'}
    ];

    const ROLES = [
      {key:'ì‰´ë”', ico:'\uD83D\uDEE1\uFE0F', desc:'200/200ìœ¼ë¡œ ì‹œì‘, ì•„êµ° ëŒ€ì‹  ë§ê¸° ê°€ëŠ¥'},
      {key:'ë¸Œë ˆì´ì»¤', ico:'\uD83D\uDD2A', desc:'ëŒ€ìƒì—ê²Œ ë‹¤ìŒ í„´ ê³µê²©ë¶ˆê°€(ì·¨ì•½ì´ë©´ 2í„´). ì‰´ë”ë¥¼ ë•Œë¦´ ë•Œ, ê³µê²©ì†ì„±ì´ ì‰´ë”ì˜ ì €í•­ì´ ì•„ë‹ˆë©´ 135 ê³ ì • í”¼í•´'},
      {key:'íëŸ¬', ico:'\u2764\uFE0F\u200D\uD83E\uDE79', desc:'ê³µê²© í›„ ì•„êµ° 1ëª… íšŒë³µ(ê¸°ë³¸ 50, ì‰´ë” ì„ íƒ ì‹œ 100)'},
      {key:'ì–´íƒœì»¤', ico:'\uD83D\uDDE1\uFE0F', desc:'ì£¼ëŠ” í”¼í•´ 2ë°°'}
    ];

    const S = { // ìƒíƒœ
      player: [],
      ai: [],
      turn: 'player',
      phase: 'selectAttacker', // 'selectTarget' | 'healSelect' | 'waiting'
      selectedAttacker: null,
      pendingHeal: null, // {by: card}
      modal: null,
      lastAIPlan: null,
      gameOver: false,
      turnCount: 1
    };

    function rng(n){ return Math.floor(Math.random()*n); }
    function pick(arr){ return arr[rng(arr.length)]; }

    function deepCopy(o){ return JSON.parse(JSON.stringify(o)); }

    function makeCard(team, idx){
      const role = ROLES[rng(ROLES.length)].key;
      const maxHp = role==='ì‰´ë”'?200:100;
      // ì†ì„± 5ê°œ ë½‘ê¸°(ê²¹ì¹˜ì§€ ì•Šê²Œ): ê³µê²©1 + ì €í•­2 + ì·¨ì•½2
      const order = ATTRS.map(a=>a.key).sort(()=>Math.random()-0.5);
      const atk = order[0], res = [order[1],order[2]], vuln=[order[3],order[4]];
      return { id: team+"-"+idx, team, role, maxHp, hp:maxHp, atk, res, vuln, stun:0, dead:false };
    }

    function newGame(){
      S.player = Array.from({length:9}, (_,i)=>makeCard('player', i+1));
      S.ai     = Array.from({length:9}, (_,i)=>makeCard('ai', i+1));
      S.turn='player'; S.phase='selectAttacker'; S.selectedAttacker=null; S.pendingHeal=null; S.lastAIPlan=null; S.gameOver=false; S.turnCount=1;
      logClear(); legendRender(); render(); setStatus(`ê²Œì„ ì‹œì‘! ë‚´ í„´ì´ì•¼. ê³µê²© ì¹´ë“œì™€ ëŒ€ìƒ ì¹´ë“œë¥¼ ìˆœì„œëŒ€ë¡œ í´ë¦­í•´ì¤˜.`);
    }

    function legendRender(){
      const el=document.getElementById('legend');
      el.innerHTML='';
      ATTRS.forEach(a=>{
        const p=document.createElement('span'); p.className='pill';
        p.innerHTML = `<span class="ico" style="color:${a.color}">${a.ico}</span>${a.key} (${a.name})`;
        el.appendChild(p);
      })
    }

    function cardColorCls(key){
      const map={ 'í™”':'fire','ë¹™':'ice','ë‡Œ':'volt','í’':'wind','ì°¸':'slash','íƒ€':'strike','ëŒ':'pierce' };
      return map[key]||'fire';
    }

    function hpBarPct(c){ return Math.max(0, Math.min(100, Math.round(100*c.hp/c.maxHp))); }

    function cardEl(card){
      const wrap=document.createElement('div');
      wrap.className = `card ${card.team==='ai'?'enemy':''} ${card.dead?'dead':''}`;
      wrap.dataset.id = card.id;

      const canSelect = !S.gameOver && S.turn==='player' && card.team==='player' && !card.dead && card.stun===0 && (S.phase==='selectAttacker' || (S.phase==='healSelect' && S.pendingHeal && card.team==='player'));
      const canTarget = !S.gameOver && S.turn==='player' && card.team==='ai' && !card.dead && S.phase==='selectTarget';

      if(!(canSelect || canTarget)) wrap.classList.add('inactive');

      wrap.onclick = ()=>{
        if(S.gameOver) return;
        if(S.turn==='player'){
          if(S.phase==='selectAttacker'){
            if(card.team!=='player' || card.dead || card.stun>0) return;
            S.selectedAttacker = card; S.phase='selectTarget'; setStatus(`${fmtCard(card)} ì„ íƒë¨. íƒ€ê²Ÿì„ ì„ íƒí•´ì¤˜.`);
            render(); return;
          }
          if(S.phase==='selectTarget'){
            if(card.team!=='ai' || card.dead) return;
            // ê³µê²© ìˆ˜í–‰ (AIê°€ ë°©ì–´í• ì§€ íŒë‹¨)
            playerAttemptAttack(S.selectedAttacker, card);
            return;
          }
          if(S.phase==='healSelect' && S.pendingHeal){
            if(card.team!=='player' || card.dead) return;
            applyHeal(S.pendingHeal.by, card);
            S.pendingHeal=null; endTurn(); return;
          }
        }
      };

      const roleMeta = ROLES.find(r=>r.key===card.role);

      wrap.innerHTML = `
        <div class="top">
          <div class="role" title="${roleMeta.desc}">${roleMeta.ico} ${card.role}</div>
          <div class="hp" title="HP">${card.hp}/${card.maxHp}</div>
        </div>
        <div class="bar"><i style="width:${hpBarPct(card)}%"></i></div>
        <div class="attrs">
          <div class="attr ${cardColorCls(card.atk)}" title="ê³µê²© ì†ì„±">
            <span class="ico">âš”ï¸</span><span>${card.atk}</span>
          </div>
          <div class="attr ${cardColorCls(card.res[0])}" title="ì €í•­ ì†ì„±">
            <span class="ico">ğŸ›¡ï¸</span><span>${card.res[0]}</span>
          </div>
          <div class="attr ${cardColorCls(card.res[1])}" title="ì €í•­ ì†ì„±">
            <span class="ico">ğŸ›¡ï¸</span><span>${card.res[1]}</span>
          </div>
          <div class="attr ${cardColorCls(card.vuln[0])}" title="ì·¨ì•½ ì†ì„±">
            <span class="ico">âš ï¸</span><span>${card.vuln[0]}</span>
          </div>
          <div class="attr ${cardColorCls(card.vuln[1])}" title="ì·¨ì•½ ì†ì„±">
            <span class="ico">âš ï¸</span><span>${card.vuln[1]}</span>
          </div>
        </div>
        <div class="badges">
          ${card.stun>0?`<span class="badge stun" title="ê³µê²© ë¶ˆê°€">ê³µê²©ë¶ˆê°€ ${card.stun}í„´</span>`:''}
        </div>
      `;
      return wrap;
    }

    function render(){
      // death check
      [...S.player, ...S.ai].forEach(c=>{ if(c.hp<=0){ c.hp=0; c.dead=true; c.stun=0; }});
      const aiRow=document.getElementById('aiRow'); const plRow=document.getElementById('playerRow');
      aiRow.innerHTML=''; plRow.innerHTML='';
      S.ai.forEach(c=> aiRow.appendChild(cardEl(c)) );
      S.player.forEach(c=> plRow.appendChild(cardEl(c)) );
      document.getElementById('turnInfo').textContent = S.gameOver? 'ê²Œì„ ì¢…ë£Œ' : (S.turn==='player'? (S.phase==='healSelect'? 'íëŸ¬ ì‚¬ìš©: íšŒë³µ ëŒ€ìƒì„ í´ë¦­' : 'ë‚´ í„´: ê³µê²© ì¹´ë“œì™€ ëŒ€ìƒ ì¹´ë“œë¥¼ ìˆœì„œëŒ€ë¡œ í´ë¦­') : 'ì ì˜ í„´: ë°©ì–´ ì—¬ë¶€ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”');
      checkGameOver();
    }

    function setStatus(msg){ document.getElementById('status').textContent = msg; }
    function log(msg){ const el=document.getElementById('log'); const p=document.createElement('p'); p.textContent=msg; el.appendChild(p); el.scrollTop=el.scrollHeight; }
    function logClear(){ document.getElementById('log').innerHTML=''; }

    function findLive(arr){ return arr.filter(c=>!c.dead); }
    function shieldsOf(arr){ return findLive(arr).filter(c=>c.role==='ì‰´ë”'); }

    function fmtCard(c){ return `${c.team==='player'?'[ë‚´]':'[ì ]'}${c.role}/${c.atk}`; }

    // ====== ì „íˆ¬ ë¡œì§ ======
    function baseDamage(attacker, target){
      // ë¸Œë ˆì´ì»¤ íŠ¹ìˆ˜: ëŒ€ìƒì´ ì‰´ë”ì´ê³  ê³µê²©ì†ì„±ì´ ëŒ€ìƒì˜ ì €í•­ì´ ì•„ë‹Œ ê²½ìš° 135 ê³ ì •
      if(attacker.role==='ë¸Œë ˆì´ì»¤' && target.role==='ì‰´ë”' && !target.res.includes(attacker.atk)){
        return 135;
      }
      if(target.res.includes(attacker.atk)) return 0;
      if(target.vuln.includes(attacker.atk)) return 45;
      return 10;
    }

    function finalDamage(attacker, target){
      let dmg = baseDamage(attacker, target);
      if(attacker.role==='ì–´íƒœì»¤') dmg *= 2;
      return dmg;
    }

    function applyDamage(target, dmg){ target.hp = Math.max(0, target.hp - Math.max(0,Math.floor(dmg))); if(target.hp===0){ target.dead=true; target.stun=0; } }

    function applyBreakerDebuff(attacker, actualDefender){
      if(attacker.role!=='ë¸Œë ˆì´ì»¤' || actualDefender.dead) return;
      const turns = actualDefender.vuln.includes(attacker.atk) ? 2 : 1; // ì·¨ì•½ì´ë©´ 2í„´
      actualDefender.stun = Math.max(actualDefender.stun, turns);
    }

    function applyHeal(healer, ally){
      if(healer.role!=='íëŸ¬' || healer.dead) return;
      const amount = (ally.role==='ì‰´ë”') ? 100 : 50;
      const prev=ally.hp; ally.hp = Math.min(ally.maxHp, ally.hp + amount);
      log(`${fmtCard(healer)} ì¹˜ìœ : [${ally.role}/${ally.atk}] ${prev}->${ally.hp}`);
      render();
    }

    // ë‚´ ê³µê²©: AIê°€ ì‰´ë“œí• ì§€ íŒë‹¨ í›„ í•´ê²°
    function playerAttemptAttack(attacker, target){
      if(!attacker || attacker.dead || attacker.stun>0) return;
      // AI ë°©ì–´ í‰ê°€
      const defenders = shieldsOf(S.ai);
      let chosenDefender = null;
      if(defenders.length){
        const plan = aiShouldGuard(attacker, target, defenders);
        if(plan.guard && plan.with) chosenDefender = plan.with;
      }

      const actualDefender = chosenDefender || target;
      const dmg = finalDamage(attacker, actualDefender);
      applyDamage(actualDefender, dmg);
      applyBreakerDebuff(attacker, actualDefender);
      log(`${fmtCard(attacker)} â–¶ ${chosenDefender?`[ì ì‰´ë” ëŒ€ì²´] `:''}[${actualDefender.role}/${actualDefender.atk}] ì—ê²Œ ${dmg} í”¼í•´`);

      // íëŸ¬ ì²˜ë¦¬(ê³µê²© í›„)
      if(attacker.role==='íëŸ¬' && !S.gameOver){
        S.pendingHeal = {by: attacker};
        S.phase='healSelect';
        setStatus('íëŸ¬ ì‚¬ìš©: íšŒë³µ ëŒ€ìƒì„ ì•„ë˜ì—ì„œ í´ë¦­í•´ì¤˜.');
        render();
      } else {
        endTurn();
      }
    }

    function endTurn(){
      if(S.gameOver){ render(); return; }
      if(S.turn==='player'){
        S.turn='ai'; S.phase='waiting';
        // ì•„êµ°(í”Œë ˆì´ì–´) ìª½ì˜ ê³µê²©ë¶ˆê°€ ê°ì†ŒëŠ” "ë‚´ í„´ ì‹œì‘ ì‹œ" ì²˜ë¦¬
        decrementStun('player');
        setTimeout(aiTurn, 450);
      } else {
        S.turn='player'; S.phase='selectAttacker'; S.selectedAttacker=null; S.turnCount++;
        decrementStun('ai');
        setStatus('ë‚´ í„´ì´ì•¼. ê³µê²© ì¹´ë“œì™€ ëŒ€ìƒ ì¹´ë“œë¥¼ ìˆœì„œëŒ€ë¡œ í´ë¦­í•´ì¤˜.');
        render();
      }
    }

    function decrementStun(team){
      const arr = team==='player'? S.player : S.ai;
      findLive(arr).forEach(c=>{ if(c.stun>0) c.stun--; });
    }

    function checkGameOver(){
      const pAlive = findLive(S.player).length;
      const aAlive = findLive(S.ai).length;
      if(!S.gameOver && (pAlive===0 || aAlive===0)){
        S.gameOver=true;
        setStatus(pAlive>0? 'ìŠ¹ë¦¬! ë‹¤ì‹œ ì‹œì‘ì„ ëˆŒëŸ¬ ìƒˆ ê²Œì„ì„ í•´ë³¼ê¹Œ?' : 'íŒ¨ë°°â€¦ ë‹¤ì‹œ ë„ì „í•´ë³¼ê¹Œ?');
        log(pAlive>0? 'ğŸ‰ ìŠ¹ë¦¬':'ğŸ’€ íŒ¨ë°°');
      }
    }

    // ====== AI ======
    function aiTurn(){
      if(S.gameOver) return;
      const attackers = findLive(S.ai).filter(c=>c.stun===0);
      if(attackers.length===0){ log('[ì ] ì‚¬ìš©í•  ì¹´ë“œê°€ ì—†ì–´ í„´ì„ ë„˜ê²¼ë‹¤'); endTurn(); return; }

      const targets = findLive(S.player);
      // ê°„ë‹¨í•œ íƒìš•ì  í‰ê°€: ìµœëŒ€ ê¸°ëŒ€ê°€ì¹˜(í”¼í•´ + ë””ë²„í”„ê°€ì¹˜)ë¥¼ ì£¼ëŠ” ì¡°í•© ì„ íƒ
      let best=null; let bestScore=-1;
      for(const atk of attackers){
        for(const t of targets){
          const shieldOptions = [null, ...shieldsOf(S.player)];
          for(const sh of shieldOptions){
            const def = sh||t;
            const dmg = finalDamage(atk, def);
            const debuffTurns = (atk.role==='ë¸Œë ˆì´ì»¤') ? (def.vuln.includes(atk.atk)?2:1) : 0;
            const debuffValue = (atk.role==='ë¸Œë ˆì´ì»¤') ? (debuffTurns*18) : 0; // ê°€ì¤‘ì¹˜
            const killBonus = (dmg>=def.hp)? 30 : 0;
            const score = dmg + debuffValue + killBonus + (atk.role==='íëŸ¬'?10:0) + (atk.role==='ì–´íƒœì»¤'?5:0);
            if(score>bestScore){ bestScore=score; best={atk, target:t, guardTarget:sh, dmg, debuffTurns}; }
          }
        }
      }
      const plan = best; S.lastAIPlan = plan;
      // ë‚´ ì‰´ë“œ ì„ íƒ íŒì—…
      openShieldModal(plan);
    }

    function openShieldModal(plan){
      const modal=document.getElementById('shieldModal');
      const txt=document.getElementById('shieldText');
      const opts=document.getElementById('shieldOptions');
      opts.innerHTML='';
      const atk=plan.atk, t=plan.target;
      txt.textContent = `ì ì´ ${fmtCard(atk)} ë¡œ [ë‚´ ${t.role}/${t.atk}] ì„(ë¥¼) ê³µê²©í•˜ë ¤ê³  í•´. ì‰´ë”ë¡œ ëŒ€ì‹  ë§ì„ë˜?`;
      const myShields = shieldsOf(S.player);
      myShields.forEach(sh=>{
        const b=document.createElement('button'); b.className='btn yellow';
        b.textContent=`ë‚´ ì‰´ë”(${sh.hp}/${sh.maxHp})ë¡œ ëŒ€ì‹  ë§ê¸°`;
        b.onclick=()=>{ closeShieldModal(); resolveAiAttack(plan, sh); };
        opts.appendChild(b);
      });
      document.getElementById('noShieldBtn').onclick=()=>{ closeShieldModal(); resolveAiAttack(plan, null); };
      document.getElementById('closeShieldBtn').onclick=()=>{ closeShieldModal(); resolveAiAttack(plan, null); };
      modal.classList.add('open');
    }
    function closeShieldModal(){ document.getElementById('shieldModal').classList.remove('open'); }

    function resolveAiAttack(plan, myShield){
      const attacker = plan.atk; const originalTarget = plan.target;
      const actualDefender = myShield || originalTarget;
      const dmg = finalDamage(attacker, actualDefender);
      applyDamage(actualDefender, dmg);
      applyBreakerDebuff(attacker, actualDefender);
      log(`${fmtCard(attacker)} â–¶ ${myShield?`[ë‚´ ì‰´ë” ëŒ€ì²´] `:''}[${actualDefender.role}/${actualDefender.atk}] ì—ê²Œ ${dmg} í”¼í•´`);
      // íëŸ¬ë¼ë©´ íšŒë³µ: ê°€ì¥ ì²´ë ¥ì´ ë‚®ì€ ì•„êµ° ìš°ì„ (ì‰´ë” ê°€ì¤‘ì¹˜)
      if(attacker.role==='íëŸ¬'){
        const allies = findLive(S.ai);
        let best = null; let score=-1;
        for(const ally of allies){
          const ratio = ally.hp/ally.maxHp;
          const val = (1-ratio) + (ally.role==='ì‰´ë”'?0.2:0);
          if(val>score){ score=val; best=ally; }
        }
        if(best) applyHeal(attacker, best);
      }
      endTurn();
    }

    // AI ë°©ì–´ ì˜ì‚¬ê²°ì •(ë‚´ ê³µê²© ì‹œ)
    function aiShouldGuard(myAttacker, myTarget, aiShieldList){
      // ì›ë˜ ë§ì„ ë•Œì˜ í”¼í•´/ë””ë²„í”„ ë¹„ìš© ê³„ì‚°
      const costNoGuard = evalDefenseCost(myAttacker, myTarget);
      let best = {guard:false, with:null, cost:costNoGuard};
      for(const sh of aiShieldList){
        const costWith = evalDefenseCost(myAttacker, sh);
        if(costWith < best.cost){ best = {guard:true, with:sh, cost:costWith}; }
      }
      return best;
    }

    function evalDefenseCost(attacker, defender){
      const dmg = finalDamage(attacker, defender);
      const lethalPenalty = (dmg>=defender.hp) ? 50 : 0; // ì£½ìœ¼ë©´ í° ì†ì‹¤
      const debuffTurns = attacker.role==='ë¸Œë ˆì´ì»¤' ? (defender.vuln.includes(attacker.atk)?2:1) : 0;
      const debuffPenalty = attacker.role==='ë¸Œë ˆì´ì»¤' ? debuffTurns*18 : 0;
      const roleWeight = defender.role==='íëŸ¬'?1.25 : defender.role==='ë¸Œë ˆì´ì»¤'?1.15 : defender.role==='ì‰´ë”'?1.1 : 1.0;
      return (dmg + lethalPenalty + debuffPenalty) * roleWeight;
    }

    // ====== ì´ë²¤íŠ¸ ======
    document.getElementById('restartBtn').onclick = newGame;
    document.getElementById('skipBtn').onclick = ()=>{ if(S.turn==='ai') return; // í…ŒìŠ¤íŠ¸ìš©: ë‚´ í„´ ìŠ¤í‚µ
      log('[ë‚´] í„´ì„ ë„˜ê²¼ë‹¤'); endTurn(); };

    // ì´ˆê¸°í™”
    newGame();
  </script>
</body>
</html>
