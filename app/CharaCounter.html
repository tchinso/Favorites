<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>글자수 계산기</title>
<style>
  :root{
    --bg:#0f1115; --fg:#e6e6e6; --muted:#9aa3b2; --accent:#6aa9ff;
    --over-bg:rgba(255,0,0,.25); --border:#222733;
    --mono:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);
            font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,"Noto Sans KR",sans-serif;}

  .wrap{max-width:980px;margin:40px auto;padding:0 16px;}
  h1{font-size:22px;font-weight:700;margin:0 0 16px;}
  .panel{border:1px solid var(--border);border-radius:12px;padding:16px;background:#0c0e13;}

  .controls{display:flex;flex-wrap:wrap;gap:12px;align-items:center;margin-bottom:12px;}
  .controls label{font-size:14px;color:var(--muted);display:flex;align-items:center;gap:8px;}
  .controls input[type="number"],.controls select{
    padding:8px 10px;border:1px solid var(--border);border-radius:10px;
    background:#0a0c10;color:var(--fg);}
  .controls input[type="number"]{width:140px;}

  .stats{display:grid;grid-template-columns:repeat(3,1fr);gap:12px;margin:8px 0 14px;}
  .stat{border:1px solid var(--border);border-radius:10px;padding:10px 12px;background:#0b0e12;}
  .stat .label{font-size:12px;color:var(--muted);margin-bottom:6px;}
  .stat .value{font-family:var(--mono);font-size:18px;}

  .editor-wrap{position:relative; isolation:isolate;}

  /* textarea + mirror ─────────────────────────── */
  textarea,.mirror{
    font:14px/1.6 var(--mono);
    padding:14px;border:1px solid var(--border);border-radius:12px;
    background:#0a0c10;height:360px;overflow:auto;

    white-space:pre-wrap;           /* 자동 줄바꿈 */
    word-break:break-word;          /* 길게 이어진 문자열도 끊기 */
  }
  textarea{
    position:relative;z-index:2;width:100%;resize:vertical;
    color:transparent;              /* 본문 글씨 숨김 → 겹침 방지 */
    -webkit-text-fill-color:transparent; /* 크로뮴 계열에서 완전 투명 처리 */
    text-shadow:none;
    caret-color:var(--fg);          /* 커서는 그대로 보이도록 */
    background:transparent;
  }
  .mirror{
    position:absolute;inset:0;z-index:1;pointer-events:none;color:var(--fg);
    scrollbar-width:none;-ms-overflow-style:none;user-select:none;
    contain:paint; /* 페인팅 격리로 중복 렌더링 방지 */
  }
  .mirror::-webkit-scrollbar{display:none;}
  .mirror .over{background:var(--over-bg);border-radius:2px;}

  .help{font-size:12px;color:var(--muted);margin-top:10px;}
  .footer{margin-top:18px;font-size:12px;color:var(--muted);}
  a{color:var(--accent);text-decoration:none;}
</style>
</head>
<body>
<div class="wrap">
  <h1>글자수 계산기</h1>

  <div class="panel">
    <div class="controls">
      <label>글자수 제한
        <input id="limit" type="number" min="0" step="1" placeholder="예: 1500">
      </label>
      <label>제한 기준
        <select id="basis">
          <option value="online" selected>X/트위터</option>
          <option value="include">공백 포함</option>
          <option value="exclude">공백 제외</option>
        </select>
      </label>
    </div>

    <div class="stats">
      <div class="stat"><div class="label">공백 제외</div><div class="value" id="v-exclude">0</div></div>
      <div class="stat"><div class="label">공백 포함</div><div class="value" id="v-include">0</div></div>
      <div class="stat"><div class="label">X/트위터</div><div class="value" id="v-online">0</div></div>
    </div>

    <div class="editor-wrap">
      <div id="mirror" class="mirror" aria-hidden="true"></div>
      <textarea id="input" spellcheck="false"
        placeholder="여기에 입력하면 실시간으로 계산해줄게…"></textarea>
    </div>

    <div class="help">
      • X/트위터 계산: ASCII 가시(U+0020–007E) + 확장 ASCII 가시(U+00A0–00FF) + 개행(Enter)=1, 그 외=2<br>
      • 공백 제외는 스페이스·탭·줄바꿈 등을 빼고 셈
    </div>
  </div>

  <div class="footer">글자수 계산기 v5.1</div>
</div>

<script>
(() => {
  const ta      = document.getElementById('input');
  const mirror  = document.getElementById('mirror');
  const limitEl = document.getElementById('limit');
  const basisEl = document.getElementById('basis');
  const vExc    = document.getElementById('v-exclude');
  const vInc    = document.getElementById('v-include');
  const vOnl    = document.getElementById('v-online');

  // ── 유틸
  const isPASCII = cp => cp>=0x20 && cp<=0x7E;      // 기본 ASCII 가시
  const isPExASCII = cp => cp>=0xA0 && cp<=0xFF;    // 확장 ASCII 가시
  const isNL = s => s==='\n' || s==='\r';         // 개행(Enter) 처리
  const isWS = s => /^\s$/u.test(s);               // 단일 공백 판정
  const esc  = s => s.replace(/[&<>"']/g, m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));

  // 안전한 그래핌(사용자 눈에 보이는 문자) 단위 분할
  const graphemes = s => {
    if (window.Intl && Intl.Segmenter) {
      const seg = new Intl.Segmenter(undefined, {granularity:'grapheme'}).segment(s);
      return Array.from(seg, x => x.segment);
    }
    return Array.from(s); // 폴백: 코드포인트
  };

  // ── 카운트
  function count(str){
    let inc=0, exc=0, onl=0;
    for(const g of graphemes(str)){
      const cp=g.codePointAt(0);
      inc++;
      if(!isWS(g)) exc++;
      // X/트위터: 개행도 1자로 취급
      onl += (isNL(g) || isPASCII(cp) || isPExASCII(cp)) ? 1 : 2;
    }
    return {inc,exc,onl};
  }

  // ── 제한 초과 시작 위치(그래핌 인덱스)
  function overflowStart(str, limit, basis){
    if(!(limit>0)) return -1;
    let acc=0, idx=0;
    const gs = graphemes(str);
    for(const g of gs){
      const cp=g.codePointAt(0);
      let add=1;
      if(basis==='exclude') add = isWS(g) ? 0 : 1;
      else if(basis==='online') add = (isNL(g) || isPASCII(cp) || isPExASCII(cp)) ? 1 : 2;
      // basis==='include' 는 add=1
      acc+=add;
      if(acc>limit) return idx;
      idx++;
    }
    return -1;
  }

  // ── 미러 그리기(그래핌 안전)
  function drawMirror(text, cut){
    const gs = graphemes(text);
    if(cut<0 || cut>=gs.length){
      mirror.innerHTML=esc(text);
      return;
    }
    const head = gs.slice(0,cut).join('');
    const tail = gs.slice(cut).join('');
    mirror.innerHTML = esc(head) + '<span class="over">' + esc(tail) + '</span>';
  }

  const syncScroll = () => { mirror.scrollTop = ta.scrollTop; mirror.scrollLeft = ta.scrollLeft; };

  function update(){
    const txt = ta.value;
    const {inc,exc,onl} = count(txt);
    vInc.textContent = inc;
    vExc.textContent = exc;
    vOnl.textContent = onl;
    drawMirror(txt, overflowStart(txt, parseInt(limitEl.value,10), basisEl.value));
  }

  ta.addEventListener('input', () => { update(); syncScroll(); });
  ta.addEventListener('scroll', syncScroll);
  limitEl.addEventListener('input', update);
  basisEl.addEventListener('change', update);

  update();
})();
</script>
</body>
</html>
