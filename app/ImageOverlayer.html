<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover, user-scalable=no" />
  <title>ëª¨ë°”ì¼ ì´ë¯¸ì§€ ì˜¤ë²„ë ˆì´ ì—ë””í„°</title>
  <style>
    :root {
      --bg: #0b0c10;
      --panel: rgba(22,24,28,0.7);
      --panel-solid: #16181c;
      --text: #e5e7eb;
      --muted: #9aa3af;
      --accent: #4f46e5;
      --accent-2: #22c55e;
      --danger: #ef4444;
      --shadow: 0 10px 30px rgba(0,0,0,0.35);
    }
    html, body { height: 100%; }
    body {
      margin: 0; color: var(--text); background: var(--bg);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Noto Sans, Helvetica, Apple SD Gothic Neo, "Apple SD ì‚°ëŒê³ ë”• Neo", Arial, "ë§‘ì€ ê³ ë”•", Malgun Gothic, "Noto Sans KR", sans-serif;
      -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;
    }
    /* ì•ˆì „ ì˜ì—­ê³¼ ì „ì²´ ë ˆì´ì•„ì›ƒ */
    .app { position: fixed; inset: 0; display: flex; flex-direction: column; }

    /* ì²´í¬ë¬´ëŠ¬ ë°°ê²½ (íˆ¬ëª… í™•ì¸ìš©) */
    .checker {
      position: absolute; inset: 0;
      background:
        linear-gradient(45deg, #111 25%, transparent 25%) -10px 0/20px 20px,
        linear-gradient(-45deg, #111 25%, transparent 25%) -10px 0/20px 20px,
        linear-gradient(45deg, transparent 75%, #111 75%) -10px 0/20px 20px,
        linear-gradient(-45deg, transparent 75%, #111 75%) -10px 0/20px 20px,
        #0e1014;
      filter: saturate(0.9) brightness(0.9);
    }

    /* ìº”ë²„ìŠ¤ ì˜ì—­ */
    .stage {
      position: relative; flex: 1; overflow: hidden; touch-action: none; /* ì œìŠ¤ì²˜ë¥¼ í˜ì´ì§€ê°€ ê°€ë¡œì±„ì§€ ì•Šê²Œ */
      background: #0e1014;
    }
    canvas { position: absolute; inset: 0; width: 100%; height: 100%; display: block; touch-action: none; }

    /* í•˜ë‹¨ ì»¨íŠ¸ë¡¤ ë°” */
    .toolbar {
      position: relative; z-index: 10; padding: env(safe-area-inset-bottom, 0);
      background: linear-gradient(180deg, transparent, rgba(0,0,0,0.35) 40%, rgba(0,0,0,0.6));
    }
    .bar {
      display: grid; gap: 10px; grid-template-columns: repeat(6, 1fr);
      padding: 12px 12px calc(12px + env(safe-area-inset-bottom));
      backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
    }
    .btn, .file-btn, .toggle {
      -webkit-tap-highlight-color: transparent;
      appearance: none; border: none; outline: none; border-radius: 14px;
      padding: 12px 10px; background: var(--panel); color: var(--text);
      text-align: center; font-weight: 600; font-size: 12px; box-shadow: var(--shadow);
    }
    .btn:active, .file-btn:active, .toggle:active { transform: translateY(1px); }
    .btn.primary { background: linear-gradient(180deg, #6366f1, #4f46e5); }
    .btn.success { background: linear-gradient(180deg, #34d399, #22c55e); }
    .btn.danger { background: linear-gradient(180deg, #f87171, #ef4444); }
    .file-btn { position: relative; overflow: hidden; }
    .file-btn input { position: absolute; inset: 0; opacity: 0; }

    .row { display: flex; align-items: center; gap: 10px; }
    .slider-wrap { grid-column: span 6; display: flex; align-items: center; gap: 10px; padding: 8px 10px; background: var(--panel); border-radius: 14px; box-shadow: var(--shadow); }
    .slider-wrap label { font-size: 12px; color: var(--muted); white-space: nowrap; }
    input[type="range"] { width: 100%; height: 28px; -webkit-appearance: none; background: transparent; }
    input[type="range"]::-webkit-slider-runnable-track { height: 6px; background: #2a2f37; border-radius: 999px; }
    input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 22px; height: 22px; border-radius: 50%; background: #a5b4fc; margin-top: -8px; box-shadow: 0 2px 8px rgba(0,0,0,0.35); }
    input[type="range"]:active::-webkit-slider-thumb { transform: scale(0.98); }

    .pill { font-size: 11px; padding: 6px 10px; border-radius: 999px; background: var(--panel); color: var(--muted); }

    .topbar { position: absolute; inset: env(safe-area-inset-top) 0 auto 0; display: flex; justify-content: space-between; align-items: center; gap: 8px; padding: 8px 12px; z-index: 11; }
    .chip { background: var(--panel); border-radius: 12px; padding: 6px 10px; box-shadow: var(--shadow); font-size: 12px; }

    .help { position: absolute; right: 12px; top: calc(12px + env(safe-area-inset-top)); z-index: 12; }
    .help-panel { position: absolute; right: 0; top: 40px; width: min(92vw, 380px); background: var(--panel-solid); border-radius: 16px; padding: 14px; box-shadow: var(--shadow); display: none; }
    .help.open + .help-panel { display: block; }
    .help-toggle { padding: 10px 14px; border-radius: 12px; background: var(--panel); }
    .help-panel h3 { margin: 0 0 8px; font-size: 14px; }
    .help-panel p, .help-panel li { color: var(--muted); font-size: 13px; line-height: 1.5; }
    .help-panel ul { margin: 8px 0 0 16px; padding: 0; }

    .toast { position: absolute; left: 50%; bottom: 120px; transform: translateX(-50%); background: rgba(15,18,25,0.9); color: #e5e7eb; padding: 10px 14px; border-radius: 999px; box-shadow: var(--shadow); font-size: 12px; display: none; }
    .toast.show { display: inline-block; }

    .hidden { display: none !important; }
    .lock { filter: saturate(0.6); }

    /* iOSì—ì„œ ì£¼ì†Œì°½ ì˜¤ë²„ë ˆì´ë¡œ ì¸í•œ ë†’ì´ ë³€í™” ëŒ€ì‘ */
    @supports (height: 100dvh) {
      .app { height: 100dvh; }
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="topbar">
      <div class="chip" id="status">ë² ì´ìŠ¤ ì´ë¯¸ì§€ ì—†ìŒ</div>
      <div class="row">
        <span class="pill" id="mode-pill">ì œìŠ¤ì²˜: ìë™</span>
        <button id="helpToggle" class="help-toggle">ë„ì›€ë§ â“</button>
      </div>
    </div>

    <div class="help" id="help">
      <div class="help-panel">
        <h3>ì‚¬ìš©ë²•</h3>
        <ul>
          <li><b>ë² ì´ìŠ¤</b> íŒŒì¼ì„ ë¨¼ì € ë¶ˆëŸ¬ì˜¤ê³ , <b>ì˜¤ë²„ë ˆì´</b> íŒŒì¼ì„ ë¶ˆëŸ¬ì™€ ê²¹ì³ìš”.</li>
          <li><b>í•œ ì†ê°€ë½</b>:
            <ul>
              <li>ì˜¤ë²„ë ˆì´ ìœ„ì—ì„œ ë“œë˜ê·¸ â†’ ì˜¤ë²„ë ˆì´ ì´ë™</li>
              <li>ì˜¤ë²„ë ˆì´ ë°–ì—ì„œ ë“œë˜ê·¸ â†’ ë² ì´ìŠ¤ íŒ¨ë‹</li>
            </ul>
          </li>
          <li><b>ë‘ ì†ê°€ë½</b> í•€ì¹˜:
            <ul>
              <li>ì˜¤ë²„ë ˆì´ ìœ„ í•€ì¹˜ â†’ ì˜¤ë²„ë ˆì´ <b>í¬ê¸° ì¡°ì • + íšŒì „</b></li>
              <li>ì˜¤ë²„ë ˆì´ ë°– í•€ì¹˜ â†’ ë² ì´ìŠ¤ <b>í™•ëŒ€/ì¶•ì†Œ</b></li>
            </ul>
          </li>
          <li>ì˜¤ë²„ë ˆì´ ë¶ˆíˆ¬ëª…ë„ëŠ” ìŠ¬ë¼ì´ë”ë¡œ ì¡°ì ˆ.</li>
          <li><b>PNG</b>ë¡œ ë‚´ë³´ë‚´ê¸°ëŠ” í•˜ë‹¨ì˜ [PNG ì €ì¥] ë²„íŠ¼.</li>
          <li>ì• ë‹ˆ GIF/WEBPëŠ” í˜„ì¬ <em>ì²« í”„ë ˆì„</em>ë§Œ ì‚¬ìš©ë¼ìš”.</li>
        </ul>
      </div>
    </div>

    <div class="stage" id="stage">
      <div class="checker"></div>
      <canvas id="canvas" aria-label="í¸ì§‘ ìº”ë²„ìŠ¤"></canvas>
      <div class="toast" id="toast"></div>
    </div>

    <div class="toolbar">
      <div class="bar">
        <label class="file-btn" title="ë² ì´ìŠ¤ ì´ë¯¸ì§€ ë¶ˆëŸ¬ì˜¤ê¸°">ë² ì´ìŠ¤
          <input id="baseInput" type="file" accept="image/*" />
        </label>
        <label class="file-btn" title="ì˜¤ë²„ë ˆì´ ì´ë¯¸ì§€ ë¶ˆëŸ¬ì˜¤ê¸°">ì˜¤ë²„ë ˆì´
          <input id="overlayInput" type="file" accept="image/*" />
        </label>
        <button class="btn" id="resetView" title="ë·° ì¬ì„¤ì •">ë¦¬ì…‹</button>
        <button class="btn toggle" id="lockBtn" title="ì˜¤ë²„ë ˆì´ ì ê¸ˆ/í•´ì œ">ì ê¸ˆ ğŸ”’</button>
        <button class="btn danger" id="clearOverlay" title="ì˜¤ë²„ë ˆì´ ì œê±°">ì§€ìš°ê¸°</button>
        <button class="btn success" id="exportBtn" title="PNGë¡œ ì €ì¥">PNG ì €ì¥</button>
        <div class="slider-wrap">
          <label for="opacity">ì˜¤ë²„ë ˆì´ ë¶ˆíˆ¬ëª…ë„</label>
          <input id="opacity" type="range" min="0" max="1" step="0.01" value="1" />
          <span class="pill" id="opacityVal">100%</span>
        </div>
      </div>
    </div>
  </div>

<script>
(()=>{
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d', { alpha: true, desynchronized: true });
  const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
  const stage = document.getElementById('stage');

  const baseInput = document.getElementById('baseInput');
  const overlayInput = document.getElementById('overlayInput');
  const exportBtn = document.getElementById('exportBtn');
  const resetViewBtn = document.getElementById('resetView');
  const lockBtn = document.getElementById('lockBtn');
  const clearOverlayBtn = document.getElementById('clearOverlay');
  const opacitySlider = document.getElementById('opacity');
  const opacityVal = document.getElementById('opacityVal');
  const status = document.getElementById('status');
  const modePill = document.getElementById('mode-pill');
  const helpToggle = document.getElementById('helpToggle');
  const help = document.getElementById('help');
  const toast = document.getElementById('toast');

  function showToast(msg, ms = 1400) {
    toast.textContent = msg;
    toast.classList.add('show');
    clearTimeout(showToast._t);
    showToast._t = setTimeout(() => toast.classList.remove('show'), ms);
  }

  // ---- ìƒíƒœ ----
  const state = {
    view: { x: 0, y: 0, scale: 1, initScale: 1 },
    base: { img: null, w: 0, h: 0, loaded: false },
    overlay: { img: null, w: 0, h: 0, loaded: false, x: 0, y: 0, scale: 1, rot: 0, opacity: 1, anchorX: .5, anchorY: .5, locked: false },
    pointers: new Map(),
    gesture: null,
    lastTap: { t: 0, x: 0, y: 0 },
    wasPinching: false,
  };

  // ---- ìˆ˜í•™ ë„ìš°ë¯¸ ----
  function mat(a=1,b=0,c=0,d=1,e=0,f=0){return {a,b,c,d,e,f};}
  function mul(m, n){return { a:m.a*n.a + m.c*n.b, b:m.b*n.a + m.d*n.b, c:m.a*n.c + m.c*n.d, d:m.b*n.c + m.d*n.d, e:m.a*n.e + m.c*n.f + m.e, f:m.b*n.e + m.d*n.f + m.f } }
  function inv(m){ const det = m.a*m.d - m.b*m.c; if(!det) return mat(); const id=1/det; return { a: m.d*id, b: -m.b*id, c: -m.c*id, d: m.a*id, e: (m.c*m.f - m.d*m.e)*id, f: (m.b*m.e - m.a*m.f)*id } }
  function apply(m, p){ return { x: m.a*p.x + m.c*p.y + m.e, y: m.b*p.x + m.d*p.y + m.f } }
  const M = {
    translate(x,y){ return mat(1,0,0,1,x,y); },
    scale(s){ return mat(s,0,0,s,0,0); },
    rotate(rad){ const cs=Math.cos(rad), sn=Math.sin(rad); return mat(cs,sn,-sn,cs,0,0); },
  };

  // ---- ì¢Œí‘œ ë³€í™˜ ----
  function screenToBase(x, y){ const v=state.view; return { x:(x - v.x)/v.scale, y:(y - v.y)/v.scale }; }
  function baseToScreen(x, y){ const v=state.view; return { x:x*v.scale + v.x, y:y*v.scale + v.y }; }

  function overlayMatrix(){
    const o = state.overlay; const ax=o.w*o.anchorX, ay=o.h*o.anchorY;
    let m = M.translate(o.x, o.y); m = mul(m, M.rotate(o.rot)); m = mul(m, M.scale(o.scale)); m = mul(m, M.translate(-ax, -ay));
    return m;
  }

  // ì˜¤ë²„ë ˆì´ íˆíŠ¸í…ŒìŠ¤íŠ¸ (ìŠ¤í¬ë¦° ì¢Œí‘œ â†’ ë² ì´ìŠ¤ â†’ ì˜¤ë²„ë ˆì´ ë¡œì»¬)
  function isPointOnOverlay(sx, sy){
    const o = state.overlay; if(!o.loaded || o.locked) return false;
    const pBase = screenToBase(sx, sy);
    const invO = inv(overlayMatrix());
    const p = apply(invO, pBase);
    return (p.x >= 0 && p.y >= 0 && p.x <= o.w && p.y <= o.h);
  }

  // ---- ìº”ë²„ìŠ¤ ----
  function resizeCanvas(){
    const rect = stage.getBoundingClientRect();
    canvas.width = Math.max(1, Math.floor(rect.width * dpr));
    canvas.height = Math.max(1, Math.floor(rect.height * dpr));
    draw();
  }
  window.addEventListener('resize', () => { resizeCanvas(); fitIfNeeded(); });

  function fitIfNeeded(){
    const { base, view } = state; if(!base.loaded) return;
    const rect = stage.getBoundingClientRect();
    const fitScale = Math.min(rect.width / base.w, rect.height / base.h);
    view.scale = Math.max(fitScale, 0.05);
    view.initScale = view.scale;
    const screenCenter = { x: rect.width/2, y: rect.height/2 };
    const contentSize = { w: base.w * view.scale, h: base.h * view.scale };
    view.x = screenCenter.x - contentSize.w/2;
    view.y = screenCenter.y - contentSize.h/2;
  }

  function resetOverlayPlacement(){
    const { base, overlay } = state; if(!base.loaded || !overlay.loaded) return;
    overlay.scale = Math.min(1, Math.max((Math.min(base.w, base.h) * 0.4) / Math.max(overlay.w, overlay.h), 0.05));
    overlay.rot = 0; overlay.x = base.w*0.5; overlay.y = base.h*0.5;
  }

  function draw(){
    const { base, overlay, view } = state;
    ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.clearRect(0,0,canvas.width,canvas.height);

    if(!base.loaded){
      ctx.save(); ctx.fillStyle='rgba(255,255,255,0.08)'; ctx.font='600 18px system-ui,-apple-system,Segoe UI,Roboto,sans-serif';
      ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText('ë² ì´ìŠ¤ ì´ë¯¸ì§€ë¥¼ ë¶ˆëŸ¬ì˜¤ì„¸ìš”', canvas.width/(2*dpr), canvas.height/(2*dpr)); ctx.restore(); return;
    }

    ctx.save(); ctx.translate(view.x, view.y); ctx.scale(view.scale, view.scale);
    ctx.drawImage(base.img, 0, 0, base.w, base.h);
    if(overlay.loaded){
      ctx.save(); const ax=overlay.w*overlay.anchorX, ay=overlay.h*overlay.anchorY;
      ctx.translate(overlay.x, overlay.y); ctx.rotate(overlay.rot); ctx.scale(overlay.scale, overlay.scale); ctx.translate(-ax,-ay);
      ctx.globalAlpha = overlay.opacity; ctx.imageSmoothingEnabled = true; ctx.imageSmoothingQuality='high';
      ctx.drawImage(overlay.img, 0, 0, overlay.w, overlay.h); ctx.restore();
    }
    ctx.restore();
  }

  // ---- ì´ë¯¸ì§€ ë¡œë“œ ----
  async function loadImageFromFile(file){
    if(!file) return null;
    // 1) ê°€ì¥ ì•ˆì •ì ì¸ ê²½ë¡œ: createImageBitmap(file)
    if('createImageBitmap' in window){
      try{
        const bmp = await createImageBitmap(file, { imageOrientation:'from-image' });
        return { source:bmp, w:bmp.width, h:bmp.height };
      }catch(e){ /* fallback */ }
    }
    // 2) ObjectURL + <img>
    const url = URL.createObjectURL(file);
    try{
      const img = await new Promise((res, rej)=>{ const im=new Image(); im.onload=()=>res(im); im.onerror=()=>rej(new Error('ì´ë¯¸ì§€ ë””ì½”ë“œ ì‹¤íŒ¨')); im.src=url; });
      const w = img.naturalWidth||img.width, h=img.naturalHeight||img.height; if(!w||!h) throw new Error('ì´ë¯¸ì§€ í¬ê¸° ì˜¤ë¥˜');
      return { source:img, w, h };
    } finally {
      // ì¼ë¶€ ë‹¨ë§ì—ì„œ ì¦‰ì‹œ revoke ì‹œ í˜ì¸íŠ¸ ì§€ì—° ì´ìŠˆ â†’ ì§€ì—° í•´ì œ
      setTimeout(()=>{ try{ URL.revokeObjectURL(url); }catch{} }, 10000);
    }
  }

  baseInput.addEventListener('change', async (e)=>{
    const file = e.target.files && e.target.files[0]; if(!file) return;
    let loaded=null; try{ loaded=await loadImageFromFile(file); }catch(err){ showToast(err.message||'ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨'); }
    if(!loaded) { showToast('ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨/ë¯¸ì§€ì› í˜•ì‹'); return; }
    state.base = { img:loaded.source, w:loaded.w, h:loaded.h, loaded:true };
    status.textContent = `ë² ì´ìŠ¤: ${file.name} (${state.base.w}Ã—${state.base.h})`;
    resizeCanvas(); fitIfNeeded(); draw(); if(state.overlay.loaded){ resetOverlayPlacement(); draw(); }
  });

  overlayInput.addEventListener('change', async (e)=>{
    const file = e.target.files && e.target.files[0]; if(!file) return;
    let loaded=null; try{ loaded=await loadImageFromFile(file); }catch(err){ showToast(err.message||'ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨'); }
    if(!loaded) { showToast('ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨/ë¯¸ì§€ì› í˜•ì‹'); return; }
    state.overlay = { ...state.overlay, img:loaded.source, w:loaded.w, h:loaded.h, loaded:true };
    status.textContent = `ì˜¤ë²„ë ˆì´: ${file.name} (${state.overlay.w}Ã—${state.overlay.h})`;
    resetOverlayPlacement(); draw();
  });

  opacitySlider.addEventListener('input', (e)=>{ state.overlay.opacity=parseFloat(e.target.value||'1'); opacityVal.textContent=Math.round(state.overlay.opacity*100)+'%'; draw(); });

  resetViewBtn.addEventListener('click', ()=>{ fitIfNeeded(); if(state.overlay.loaded) resetOverlayPlacement(); draw(); showToast('ë·°/ì˜¤ë²„ë ˆì´ ì¬ì„¤ì •'); });

  lockBtn.addEventListener('click', ()=>{ state.overlay.locked=!state.overlay.locked; lockBtn.textContent= state.overlay.locked? 'ì ê¸ˆ ğŸ”’':'ì ê¸ˆ ğŸ”“'; lockBtn.classList.toggle('lock', state.overlay.locked); showToast(state.overlay.locked?'ì˜¤ë²„ë ˆì´ ì ê¸ˆ':'ì˜¤ë²„ë ˆì´ í•´ì œ'); });

  clearOverlayBtn.addEventListener('click', ()=>{ const keepOpacity=state.overlay.opacity; state.overlay={ img:null,w:0,h:0,loaded:false,x:0,y:0,scale:1,rot:0,opacity:keepOpacity,anchorX:.5,anchorY:.5,locked:false}; draw(); showToast('ì˜¤ë²„ë ˆì´ ì œê±°'); });

  exportBtn.addEventListener('click', ()=>{ if(!state.base.loaded){ showToast('ë² ì´ìŠ¤ ì´ë¯¸ì§€ê°€ í•„ìš”í•´ìš”'); return; } const url=canvas.toDataURL('image/png'); const a=document.createElement('a'); a.href=url; a.download='overlayed.png'; document.body.appendChild(a); a.click(); a.remove(); try{ window.open(url,'_blank'); }catch{} showToast('PNGë¡œ ë‚´ë³´ëƒˆì–´ìš”'); });

  helpToggle.addEventListener('click', ()=> help.classList.toggle('open'));

  // ---- ì œìŠ¤ì²˜ (Pointer Events) ----
  canvas.addEventListener('pointerdown', onPointerDown, {passive:false});
  canvas.addEventListener('pointermove', onPointerMove, {passive:false});
  canvas.addEventListener('pointerup', onPointerUp, {passive:false});
  canvas.addEventListener('pointercancel', onPointerUp, {passive:false});
  canvas.addEventListener('gesturestart', e=>e.preventDefault());
  canvas.addEventListener('gesturechange', e=>e.preventDefault());
  canvas.addEventListener('gestureend', e=>e.preventDefault());

  function onPointerDown(e){
    e.preventDefault(); try{ e.target.setPointerCapture && e.target.setPointerCapture(e.pointerId);}catch{}
    state.pointers.set(e.pointerId, { x:e.clientX, y:e.clientY });
    const pts=[...state.pointers.values()];
    if(pts.length===1){
      const target = isPointOnOverlay(e.clientX,e.clientY) ? 'overlay':'base';
      modePill.textContent = `ì œìŠ¤ì²˜: ${target==='overlay'?'ì˜¤ë²„ë ˆì´':'ë² ì´ìŠ¤'}`;
      if(target==='overlay'){
        const basePt=screenToBase(e.clientX,e.clientY);
        state.gesture={ target, mode:'drag', start:{ basePt, x:state.overlay.x, y:state.overlay.y } };
      } else {
        state.gesture={ target, mode:'drag', start:{ x:state.view.x, y:state.view.y, last:{ x:e.clientX, y:e.clientY } } };
      }
    } else if(pts.length===2){
      state.wasPinching=true;
      const p1=pts[0], p2=pts[1];
      const mid={ x:(p1.x+p2.x)/2, y:(p1.y+p2.y)/2 }; const dist=Math.hypot(p2.x-p1.x,p2.y-p1.y); const ang=Math.atan2(p2.y-p1.y,p2.x-p1.x);
      const target = isPointOnOverlay(mid.x, mid.y) ? 'overlay':'base';
      modePill.textContent = `ì œìŠ¤ì²˜: ${target==='overlay'?'ì˜¤ë²„ë ˆì´':'ë² ì´ìŠ¤'}`;
      if(target==='overlay'){
        const baseMid=screenToBase(mid.x,mid.y);
        state.gesture={ target, mode:'pinch', start:{ midScreen:mid, baseMid, dist, ang, x:state.overlay.x, y:state.overlay.y, scale:state.overlay.scale, rot:state.overlay.rot } };
      } else {
        const v=state.view; const world=screenToBase(mid.x,mid.y);
        state.gesture={ target, mode:'pinch', start:{ mid, dist, world, scale:v.scale, x:v.x, y:v.y } };
      }
    }
  }

  function onPointerMove(e){
    if(!state.pointers.has(e.pointerId)) return; e.preventDefault();
    state.pointers.set(e.pointerId, { x:e.clientX, y:e.clientY });
    const g=state.gesture; if(!g) return; const pts=[...state.pointers.values()];
    if(g.mode==='drag' && pts.length===1){
      if(g.target==='overlay'){
        const basePt=screenToBase(e.clientX,e.clientY); const dx=basePt.x-g.start.basePt.x, dy=basePt.y-g.start.basePt.y;
        state.overlay.x=g.start.x+dx; state.overlay.y=g.start.y+dy;
      } else {
        const last=g.start.last; const dx=e.clientX-last.x, dy=e.clientY-last.y; state.view.x=g.start.x+dx; state.view.y=g.start.y+dy;
      }
      draw();
    }
    if(pts.length===2 && g.mode==='pinch'){
      const p1=pts[0], p2=pts[1]; const mid={ x:(p1.x+p2.x)/2, y:(p1.y+p2.y)/2 }; const dist=Math.hypot(p2.x-p1.x,p2.y-p1.y); const ang=Math.atan2(p2.y-p1.y,p2.x-p1.x);
      if(g.target==='overlay'){
        const scaleFactor=Math.max(0.02, dist/g.start.dist); state.overlay.scale=Math.max(0.02, Math.min(100, g.start.scale*scaleFactor));
        state.overlay.rot=g.start.rot+(ang-g.start.ang);
        const baseMid=screenToBase(mid.x,mid.y); state.overlay.x=g.start.x+(baseMid.x-g.start.baseMid.x); state.overlay.y=g.start.y+(baseMid.y-g.start.baseMid.y);
      } else {
        const scale = clamp(g.start.scale * (dist / g.start.dist), 0.02, 50); state.view.scale=scale; state.view.x=g.start.mid.x - g.start.world.x*scale; state.view.y=g.start.mid.y - g.start.world.y*scale;
      }
      draw();
    }
  }

  function onPointerUp(e){
    e.preventDefault(); state.pointers.delete(e.pointerId); if(state.pointers.size<2) state.gesture=null;
    if(state.wasPinching){ if(state.pointers.size===0){ setTimeout(()=>{ state.wasPinching=false; },0); } return; }
    // ë”ë¸”íƒ­ ë¦¬ì…‹ ë¹„í™œì„±í™” (ì‚¬ìš©ì ìš”ì²­)
    const now=performance.now(); if(false && now-state.lastTap.t<300){ /* disabled */ } else { state.lastTap={ t:now, x:e.clientX, y:e.clientY }; }
  }

  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

  // ---- ì´ˆê¸°í™” ----
  resizeCanvas(); showToast('ë² ì´ìŠ¤ë¥¼ ë¶ˆëŸ¬ì˜¤ì„¸ìš”');
})();
</script>
</body>
</html>
